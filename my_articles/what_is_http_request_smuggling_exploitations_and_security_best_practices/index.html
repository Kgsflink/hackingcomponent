<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>What is HTTP Request Smuggling? Exploitations and Security Best Practices</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Source+Sans+Pro:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --primary: #2a4365;
            --primary-light: #4299e1;
            --secondary: #c05621;
            --text: #2d3748;
            --text-light: #4a5568;
            --background: #f7fafc;
            --card-bg: #ffffff;
            --border: #e2e8f0;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --radius: 8px;
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Source Sans Pro', sans-serif;
            line-height: 1.8;
            color: var(--text);
            background-color: var(--background);
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            background-color: var(--primary);
            color: white;
            padding: 80px 0 40px;
            margin-bottom: 60px;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, var(--primary-light), var(--secondary));
        }

        .header-content {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
            position: relative;
            z-index: 1;
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.8rem;
            margin-bottom: 20px;
            line-height: 1.3;
            color: white;
        }

        .meta {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95rem;
        }

        .meta i {
            margin-right: 5px;
            color: var(--primary-light);
        }

        .article-container {
            display: grid;
            grid-template-columns: 1fr min(800px, 100%) 1fr;
            margin-bottom: 80px;
        }

        .article-container > * {
            grid-column: 2;
        }

        .content {
            background-color: var(--card-bg);
            padding: 50px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            font-size: 1.1rem;
            color: var(--text);
        }

        .content p {
            margin-bottom: 1.5em;
        }

        .content img.blog-image {
            max-width: 100%;
            height: auto;
            margin: 40px auto;
            display: block;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .content img.blog-image:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .image-container {
            margin: 40px 0;
            text-align: center;
        }

        .image-container figcaption {
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--text-light);
            font-style: italic;
        }

        .section-heading {
            font-family: 'Playfair Display', serif;
            color: var(--primary);
            margin: 60px 0 30px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border);
            font-size: 1.8rem;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 30px 0;
            font-size: 0.95rem;
            box-shadow: var(--shadow);
            border-radius: var(--radius);
            overflow: hidden;
        }

        .data-table th, .data-table td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border);
        }

        .data-table th {
            background-color: var(--primary);
            color: white;
            font-weight: 600;
        }

        .data-table tr:nth-child(even) {
            background-color: var(--background);
        }

        .table-container {
            margin: 40px 0;
            overflow-x: auto;
        }

        .code-block {
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: var(--radius);
            overflow-x: auto;
            margin: 30px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        blockquote {
            border-left: 4px solid var(--primary-light);
            padding: 20px;
            margin: 30px 0;
            background-color: var(--background);
            font-style: italic;
            color: var(--text-light);
        }

        blockquote::before {
            content: '“';
            font-size: 3rem;
            color: var(--primary-light);
            line-height: 0;
            vertical-align: -0.4em;
            margin-right: 10px;
        }

        a {
            color: var(--primary-light);
            text-decoration: none;
            transition: var(--transition);
        }

        a:hover {
            color: var(--secondary);
            text-decoration: underline;
        }

        footer {
            text-align: center;
            padding: 30px 0;
            margin-top: 60px;
            border-top: 1px solid var(--border);
            color: var(--text-light);
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .content {
                padding: 30px;
            }
            
            .article-container {
                grid-template-columns: 1fr;
            }
        }
    </style>

</head>
<body>
    <header>
        <h1>What is HTTP Request Smuggling? Exploitations and Security Best Practices</h1>
        <div class="meta">
            <span class="date">March 13, 2025</span> • <span class="author">kgsflink</span>
        </div>
    </header>
    
    <article class="content">
        <article class="the-post post-13042 post type-post status-publish format-standard category-technical" id="post-13042">
<header class="post-header the-post-header cf">

<div class="featured">
</div>
</header><!-- .post-header -->
<div class="post-content description cf entry-content content-spacious">
<div class="wp-block-image">
<figure class="alignright size-large is-resized"><img alt="What is HTTP Request Smuggling? Exploitations and Security Best Practices" class="wp-image-13043" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/03/exploiting-preventing-http-request-smuggling-1024x535.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/03/exploiting-preventing-http-request-smuggling-300x157.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/03/exploiting-preventing-http-request-smuggling-1536x803.png 1536w" decoding="async" fetchpriority="high" height="535" src="images/1_what_is_http_request_smuggling_exploitations_and_security_best_practices.png" style="width:420px;height:auto" width="1024"/><noscript><img alt="What is HTTP Request Smuggling? Exploitations and Security Best Practices" class="wp-image-13043" decoding="async" fetchpriority="high" height="535" sizes="(max-width: 1024px) 100vw, 1024px" src="images/2_what_is_http_request_smuggling_exploitations_and_security_best_practices.png" style="width:420px;height:auto" width="1024"/></noscript></figure></div>
<p>When a client accesses a website, it communicates with the server through the HTTP protocol. Initially text-based, this protocol became binary with HTTP/2, but its operation is still based on TCP.</p>
<p>Each exchange begins with the creation of a connection between the client and the server. With HTTP/1.0, this connection was closed after each request. But with HTTP/1.1, the Keep-Alive mode became the norm, allowing the connection to be kept open for several successive exchanges.</p>
<span id="more-13042"></span>
<p>HTTP/1.1 also saw the introduction of the Transfer-Encoding header, used to indicate how the body of the request should be interpreted. This development, although beneficial in terms of performance and efficiency, also introduced new vulnerabilities.</p>
<p>These include <strong>HTTP request smuggling</strong>, an attack that exploits inconsistencies in the processing of HTTP requests by servers and proxies.</p>
<p>In this article, we take a closer look at how HTTP request smuggling works, its different variants and strategies for protecting against it.</p>
<h2 class="wp-block-heading">Comprehensive Guide to HTTP Request Smuggling</h2>
<div class="wp-block-aioseo-table-of-contents"><ul><li><a href="#what-is-http-request-smuggling">What is HTTP Request Smuggling?</a><ul><li><a href="#http-request-smuggling-attack-principle">HTTP Request Smuggling attack principle</a></li><li><a href="#understanding-desynchronisation-via-content-length-and-transfer-encoding">Understanding desynchronisation via Content-Length and Transfer-Encoding</a></li></ul></li><li><a href="#exploitation-of-an-http-request-smuggling-vulnerability">Exploitation of an HTTP Request Smuggling Vulnerability</a></li><li><a href="#http-2-downgrading-and-request-smuggling">HTTP/2 Downgrading and Request Smuggling</a><ul><li><a href="#crlf-injection-and-http-2-exploitation">CRLF injection and http/2 exploitation</a></li><li><a href="#other-variants-of-request-smuggling">Other variants of request smuggling</a></li></ul></li><li><a href="#tools-for-identifying-and-exploiting-request-smuggling-vulnerabilities">Tools for Identifying and Exploiting Request Smuggling Vulnerabilities</a><ul><li><a href="#smuggler-py">Smuggler.py</a></li><li><a href="#http-request-smuggler">HTTP Request Smuggler</a></li></ul></li><li><a href="#how-to-prevent-http-request-smuggling">How to Prevent HTTP Request Smuggling?</a></li></ul></div>
<h2 class="wp-block-heading" id="what-is-http-request-smuggling">What is HTTP Request Smuggling?</h2>
<p><strong>HTTP request smuggling is a vulnerability that allows an attacker to manipulate requests exchanged between a client and an intermediary server, often a proxy or a load balancer.</strong></p>
<p>By manipulating the way these systems interpret the Content-Length and Transfer-Encoding headers, it is possible to inject malicious requests, bypass security controls or execute actions without the knowledge of legitimate users.</p>
<p>This vulnerability exploits differences in the interpretation of HTTP requests between several servers on the same infrastructure.</p>
<p>For a request smuggling attack to be possible, two conditions must be met:</p>
<ol class="wp-block-list">
<li>The target server must be placed behind an intermediary server (reverse proxy, load balancer, etc.).</li>
<li>One or both of the servers must be using the HTTP/1.1 protocol, as this attack is no longer possible with HTTP/2.</li>
</ol>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-60b656f76d1e4b65d21710ca9a91c28f" id="http-request-smuggling-attack-principle" style="color:#c0b800">HTTP Request Smuggling attack principle</h3>
<p>The aim of an HTTP request smuggling attack is to desynchronise communication between the front-end server (proxy or load balancer) and the back-end server. This desynchronisation occurs when these two servers interpret the size of the body of an HTTP request differently.</p>
<p>The problem arises mainly from the coexistence of the Content-Length and Transfer-Encoding headers. Normally, a server uses Content-Length to define the size of the content of a request. However, if one of the servers supports Transfer-Encoding, but the other does not, ambiguity can arise.</p>
<p>By exploiting this confusion, an attacker can :</p>
<ul class="wp-block-list">
<li><strong>Inject malicious requests</strong> into the communication flow.</li>
<li><strong>Force other users to execute requests without their knowledge</strong>.</li>
<li><strong>Intercept HTTP responses intended for other users.</strong></li>
<li><strong>Pollute a server’s response queue</strong>, causing malfunctions similar to a <a href="https://www.vaadata.com/blog/what-is-a-dos-attack-types-exploitations-and-security-tips/" rel="noopener" target="_blank" title="">DoS attack</a>, while allowing sensitive information to be stolen.</li>
</ul>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-193e6b8364ab44e78436b34ffc8c4167" id="understanding-desynchronisation-via-content-length-and-transfer-encoding" style="color:#c0b800">Understanding desynchronisation via Content-Length and Transfer-Encoding</h3>
<p>When an HTTP request contains both the Content-Length and Transfer-Encoding headers, it should be rejected with a 400 Bad Request error. However, if this is not the case, and the receiving server supports Transfer-Encoding, it is this header that will be used to determine the size of the request body.</p>
<p>The problem arises when the two servers involved in processing the request do not interpret these headers in the same way. If only one of the two servers recognises Transfer-Encoding, while the other uses Content-Length, desynchronisation can occur.</p>
<p>The backend server may then not read the entire body of the request, leaving an unused part which will be interpreted as the start of a new request during the next exchange, provided that the connection between the frontend and the backend remains open.</p>
<p>Several configurations can lead to desynchronisation:</p>
<ul class="wp-block-list">
<li><strong>CL.TE</strong>: The frontend server ignores Transfer-Encoding, but the backend interprets it.</li>
<li><strong>TE.CL</strong>: The frontend recognises Transfer-Encoding, but the backend does not use it.</li>
<li><strong>TE.TE</strong>: Both servers support Transfer-Encoding, but one of them ignores the header if its syntax is malformed.</li>
</ul>
<p>The last case (TE.TE) exploits a difference in interpretation (differential parsing) between the reverse proxy and the backend server. A specially crafted request can thus cause desynchronisation and enable request smuggling attacks.</p>
<p>Overall, these scenarios are based on the same principle: forcing servers to interpret an HTTP request differently, thus opening the door to stealth injections and hijacking of communication flows.</p>
<h2 class="wp-block-heading" id="exploitation-of-an-http-request-smuggling-vulnerability">Exploitation of an HTTP Request Smuggling Vulnerability</h2>
<p>One of the most common attack scenarios consists of exploiting desynchronisation to inject a prohibited request through the reverse proxy, without it detecting it.</p>
<p>In practice, the reverse proxy will only analyse the first request and judge it to be compliant with the defined access rules. However, in the background, the backend server will actually receive two separate requests:</p>
<ul class="wp-block-list">
<li>The first, legitimate, which complies with the restrictions imposed.</li>
<li>The second, hidden, targets a resource that is normally inaccessible to a standard user.</li>
</ul>
<p>This allows an attacker to bypass reverse proxy-based access controls and access normally protected paths, exposing sensitive data or critical features.</p>
<p>Initial responses for /admin:</p>
<figure class="wp-block-image size-large"><img alt="" class="wp-image-13023" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/03/request-response-admin-1024x322.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/03/request-response-admin-300x94.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/03/request-response-admin-1536x482.png 1536w" decoding="async" height="322" src="images/2_request-response-admin-1024x322.png" width="1024"/><noscript><img alt="" class="wp-image-13023" decoding="async" height="322" sizes="(max-width: 1024px) 100vw, 1024px" src="images/3_request-response-admin-1024x322.png" width="1024"/></noscript></figure>
<figure class="wp-block-image size-large"><img alt="" class="wp-image-13025" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/03/request-response-admin-1-1024x558.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/03/request-response-admin-1-300x164.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/03/request-response-admin-1-1536x838.png 1536w" decoding="async" height="558" src="images/3_request-response-admin-1-1024x558.png" width="1024"/><noscript><img alt="" class="wp-image-13025" decoding="async" height="558" sizes="(max-width: 1024px) 100vw, 1024px" src="images/4_request-response-admin-1-1024x558.png" width="1024"/></noscript></figure>
<p>We can see that the reverse proxy route restriction has been bypassed.</p>
<p>Once the reverse proxy restriction has been bypassed, an attacker can exploit the vulnerability to his own advantage. For example, he can self-target to intercept the response to a request that he has sent directly to the backend server, without it being filtered by the proxy. This represents a major threat to the access control of a web platform.</p>
<p>However, request smuggling is not limited to this type of attack. It can also be used to:</p>
<ul class="wp-block-list">
<li><strong>Force a user to execute a request involuntarily</strong> (the targeted user will be the one who sends the next request).</li>
<li><strong>Inject malicious code (reflected <strong>XSS</strong>)</strong> to compromise other users.</li>
<li><strong>Desynchronise the HTTP response queue</strong> (<a href="https://portswigger.net/web-security/request-smuggling/advanced/response-queue-poisoning" rel="noopener" target="_blank" title="">response queue poisoning</a>), resulting in incorrect or random responses being displayed to subsequent users.</li>
<li><strong>Launch a DoS attack</strong> by disrupting the processing of requests and responses on the platform.</li>
</ul>
<p>These scenarios show just how critical and difficult to detect this vulnerability can be.</p>
<h2 class="wp-block-heading" id="http-2-downgrading-and-request-smuggling">HTTP/2 Downgrading and Request Smuggling</h2>
<p>The HTTP/2 protocol was designed to eliminate several vulnerabilities in HTTP/1.1, in particular by ceasing to use headers to determine the length of requests. In theory, this prevents any exploitation of request smuggling.</p>
<p>However, if a frontend server uses HTTP/2 but rewrites requests in HTTP/1.1 to communicate with a backend, a vulnerability may arise.</p>
<p>In this case, the attacker can exploit this conversion to inject malicious requests and cause desynchronisation similar to classic request smuggling attacks.</p>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-08f57f7e6c9af783664ea6f6fe9c1daa" id="crlf-injection-and-http-2-exploitation" style="color:#c0b800">CRLF injection and http/2 exploitation </h3>
<p>When attempting to exploit request smuggling in HTTP/2 to HTTP/1.1, it is often necessary to use a CRLF injection (Carriage Return Line Feed).</p>
<p>Unlike HTTP/1.1, which is text-based, HTTP/2 is a binary protocol and no longer uses the same delimiters to structure requests. When a frontend server converts an HTTP/2 request into HTTP/1.1, it may interpret certain binary characters as line breaks (<code>\r\n</code> or <code>%0D%0A</code>), allowing an attacker to inject additional headers and manipulate the rewritten request.</p>
<p>A typical example of exploitation involves injecting the sequence <code>\r\n</code> into a modifiable header to force the addition of an unanticipated Transfer-Encoding header, resulting in desynchronisation between the proxy and the backend server.</p>
<p>This type of request, once corrupted by CRLF injection, is sometimes referred to as ‘Kettled’, in reference to James Kettle’s research on the subject.</p>
<figure class="wp-block-image size-large"><img alt="" class="wp-image-13029" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/03/crlf-injection-1024x566.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/03/crlf-injection-300x166.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/03/crlf-injection-1536x849.png 1536w" decoding="async" height="566" src="images/4_crlf-injection-1024x566.png" width="1024"/><noscript><img alt="" class="wp-image-13029" decoding="async" height="566" sizes="(max-width: 1024px) 100vw, 1024px" src="images/5_crlf-injection-1024x566.png" width="1024"/></noscript></figure>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-520ad7993bd5c013056521bb0ca67f6d" id="other-variants-of-request-smuggling" style="color:#c0b800">Other variants of request smuggling</h3>
<p>Although this article focuses on the classic forms of request smuggling, there are many variations, including:</p>
<ul class="wp-block-list">
<li><strong>Client-side desynchronization (Client Side Desync)</strong>, which exploits differences in client-side processing.</li>
<li><strong>HTTP/2 Request Smuggling</strong>, an attack specifically targeting conversion flaws between HTTP/2 and HTTP/1.1.</li>
<li><strong>Pause-Based Request Smuggling</strong>, which exploits processing delays to force desynchronisation.</li>
</ul>
<p>These advanced techniques enable attackers to exploit the subtleties of communications between servers, underlining the complexity and constant evolution of attacks linked to HTTP protocols.</p>
<h2 class="wp-block-heading" id="tools-for-identifying-and-exploiting-request-smuggling-vulnerabilities">Tools for Identifying and Exploiting Request Smuggling Vulnerabilities</h2>
<p>Exploiting vulnerabilities related to request smuggling can be complex, particularly given the subtleties of desynchronisation between the frontend and backend servers.</p>
<p>Fortunately, there are a number of tools available to automate the detection and exploitation of these vulnerabilities.</p>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-83a0b60e765224ed837b1f285ca56968" id="smuggler-py" style="color:#c0b800">Smuggler.py</h3>
<p><a href="https://github.com/gwen001/pentest-tools/blob/master/smuggler.py" rel="noopener" target="_blank" title=""><strong>Smuggler.py</strong></a> is a specialised scanner designed to identify HTTP desynchronisation within a server or a list of hosts. It automates the search for the three main types of request smuggling:</p>
<ul class="wp-block-list">
<li><strong>CL.TE</strong> (Content-Length vs Transfer-Encoding).</li>
<li><strong>TE.CL</strong> (Transfer-Encoding vs Content-Length).</li>
<li><strong>TE.TE</strong> (variants exploiting Transfer-Encoding parsing errors).</li>
</ul>
<p>The tool can also be used to add mutations to refine tests, particularly for TE.TE attacks.</p>
<p>Although it is no longer actively maintained, it remains a relevant choice for scanning large test perimeters and detecting vulnerabilities.</p>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-f81cf7ca605dd84d0316bdda7a8762ed" id="http-request-smuggler" style="color:#c0b800">HTTP Request Smuggler</h3>
<p>Burp Suite’s <strong>HTTP Request Smuggler</strong> extension simplifies the exploitation of request smuggling vulnerabilities.</p>
<p>It automates certain critical adjustments, such as calculating the offsets required for TE.CL attacks. The extension relies on Turbo Intruder, an advanced fuzzing tool, to probe server behaviour and optimise attacks.</p>
<p>By combining these tools with an in-depth understanding of how HTTP servers and proxies work, it becomes possible to effectively detect and exploit request smuggling vulnerabilities, particularly in environments where differences in request processing can be manipulated for malicious purposes.</p>
<h2 class="wp-block-heading" id="how-to-prevent-http-request-smuggling">How to Prevent HTTP Request Smuggling?</h2>
<p>Request smuggling is based on a weakness in the HTTP/1.1 protocol. If all the servers on a platform use HTTP/2, this attack becomes impossible, as the differences in interpretation between the frontend and backend no longer exist.</p>
<p>However, migrating to HTTP/2 is not always an immediate option. In this case, several measures can be put in place to protect against this vulnerability:</p>
<ul class="wp-block-list">
<li><strong>Reject ambiguous requests containing both Content-Length and Transfer-Encoding</strong>, on both the frontend and the backend.</li>
<li><strong>Avoid reusing connections between the frontend server and the backend</strong> in order to prevent the persistence of out-of-sync requests.</li>
<li><strong>Deploy a WAF</strong> configured to detect and block attempts to exploit request smuggling.</li>
<li><strong>Harmonise the technology stack</strong> by using the same server for the frontend and backend (such as Nginx), to avoid differences in parsing and interpretation of HTTP requests.</li>
</ul>
<p>Strict application of these best practices considerably reduces the risks associated with HTTP request smuggling, and prevents attackers from exploiting this vulnerability to manipulate traffic or intercept requests.</p>
<p><strong>Author: kgsflink</strong></p>
</div><!-- .post-content -->
<div class="the-post-foot cf">

</div>

</article>
    </article>
</body>
</html>