<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JWT (JSON Web Token): Vulnerabilities, Common Attacks and Security Best Practices</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Source+Sans+Pro:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --primary: #2a4365;
            --primary-light: #4299e1;
            --secondary: #c05621;
            --text: #2d3748;
            --text-light: #4a5568;
            --background: #f7fafc;
            --card-bg: #ffffff;
            --border: #e2e8f0;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --radius: 8px;
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Source Sans Pro', sans-serif;
            line-height: 1.8;
            color: var(--text);
            background-color: var(--background);
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            background-color: var(--primary);
            color: white;
            padding: 80px 0 40px;
            margin-bottom: 60px;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, var(--primary-light), var(--secondary));
        }

        .header-content {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
            position: relative;
            z-index: 1;
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.8rem;
            margin-bottom: 20px;
            line-height: 1.3;
            color: white;
        }

        .meta {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.95rem;
        }

        .meta i {
            margin-right: 5px;
            color: var(--primary-light);
        }

        .article-container {
            display: grid;
            grid-template-columns: 1fr min(800px, 100%) 1fr;
            margin-bottom: 80px;
        }

        .article-container > * {
            grid-column: 2;
        }

        .content {
            background-color: var(--card-bg);
            padding: 50px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            font-size: 1.1rem;
            color: var(--text);
        }

        .content p {
            margin-bottom: 1.5em;
        }

        .content img.blog-image {
            max-width: 100%;
            height: auto;
            margin: 40px auto;
            display: block;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .content img.blog-image:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .image-container {
            margin: 40px 0;
            text-align: center;
        }

        .image-container figcaption {
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--text-light);
            font-style: italic;
        }

        .section-heading {
            font-family: 'Playfair Display', serif;
            color: var(--primary);
            margin: 60px 0 30px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border);
            font-size: 1.8rem;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 30px 0;
            font-size: 0.95rem;
            box-shadow: var(--shadow);
            border-radius: var(--radius);
            overflow: hidden;
        }

        .data-table th, .data-table td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border);
        }

        .data-table th {
            background-color: var(--primary);
            color: white;
            font-weight: 600;
        }

        .data-table tr:nth-child(even) {
            background-color: var(--background);
        }

        .table-container {
            margin: 40px 0;
            overflow-x: auto;
        }

        .code-block {
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: var(--radius);
            overflow-x: auto;
            margin: 30px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        blockquote {
            border-left: 4px solid var(--primary-light);
            padding: 20px;
            margin: 30px 0;
            background-color: var(--background);
            font-style: italic;
            color: var(--text-light);
        }

        blockquote::before {
            content: '“';
            font-size: 3rem;
            color: var(--primary-light);
            line-height: 0;
            vertical-align: -0.4em;
            margin-right: 10px;
        }

        a {
            color: var(--primary-light);
            text-decoration: none;
            transition: var(--transition);
        }

        a:hover {
            color: var(--secondary);
            text-decoration: underline;
        }

        footer {
            text-align: center;
            padding: 30px 0;
            margin-top: 60px;
            border-top: 1px solid var(--border);
            color: var(--text-light);
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .content {
                padding: 30px;
            }
            
            .article-container {
                grid-template-columns: 1fr;
            }
        }
    </style>

</head>
<body>
    <header>
        <h1>JWT (JSON Web Token): Vulnerabilities, Common Attacks and Security Best Practices</h1>
        <div class="meta">
            <span class="date">April 30, 2025</span> • <span class="author">kgsflink</span>
        </div>
    </header>
    
    <article class="content">
        <article class="the-post post-1648 post type-post status-publish format-standard category-technical" id="post-1648">
<header class="post-header the-post-header cf">

<div class="featured">
</div>
</header><!-- .post-header -->
<div class="post-content description cf entry-content content-spacious">
<figure class="wp-block-image size-full"><img alt="JWT (JSON Web Token): Vulnerabilities, Common Attacks and Security Best Practices" class="wp-image-13333" decoding="async" fetchpriority="high" height="450" sizes="(max-width: 800px) 100vw, 800px" src="images/1_jwt_(json_web_token)_vulnerabilities,_common_attacks_and_security_best_practices.png" width="800"/></figure>
<span id="more-1648"></span>
<h2 class="wp-block-heading">Introduction</h2>
<p>When developing a web application, authentication is an essential component. Depending on the technologies used, authentication can be stateful or stateless.</p>
<p>In a stateful model, authentication is based on server-side session management. When a user connects, the server generates a unique session identifier. This identifier is then sent with each request so that the server can retrieve information relating to the user. It is therefore the server that maintains the state of the session throughout the browsing session.</p>
<p>Conversely, in a stateless approach, it is the client – often the browser – that stores the session information, generally in the form of a signed or encrypted token. Each time a request is made, this token is transmitted to the server, which can then check it and extract the necessary data. The server keeps no trace of the session, hence the term stateless. This authentication method is used in particular with JWT tokens (JSON Web Tokens).</p>
<p>Increasingly used, JWTs are not, however, free of vulnerabilities, and poor implementation can expose applications to potentially disastrous attacks.</p>
<p>In this article, we’ll take a closer look at how JWTs work. We will also review the common vulnerabilities associated with JWTs, attack techniques and best practices for configuration and implementation to minimise these risks.</p>
<h2 class="wp-block-heading">Comprehensive Guide to JSON Web Tokens (JWT)</h2>
<div class="wp-block-aioseo-table-of-contents"><ul><li><a href="#how-does-a-jwt-work">How Does a JWT Work?</a><ul><li><a href="#what-is-jwt">What is JWT?</a></li><li><a href="#jwt-structure-and-generation">JWT structure and generation</a><ul><li><a href="#jose-header">JOSE header</a></li><li><a href="#payload">Payload</a></li><li><a href="#signature">Signature</a><ul><li><a href="#the-crucial-role-of-the-signature-in-jwt-security">The crucial role of the signature in JWT security</a></li><li><a href="#signing-algorithms-symmetric-hs256-vs-asymmetric-rs256">Signing algorithms: symmetric (HS256) vs. asymmetric (RS256)</a></li></ul></li></ul></li></ul></li><li><a href="#pros-and-cons-of-jwts">Pros And Cons of JWTs</a></li><li><a href="#what-are-the-most-common-jwt-vulnerabilities-and-exploitations">What are the Most Common JWT Vulnerabilities and Exploitations?</a><ul><li><a href="#jwt-signature-not-verified">JWT signature not verified</a></li><li><a href="#exploiting-the-none-algorithm">Exploiting the "none" algorithm</a><ul><li><a href="#understanding-the-risks-associated-with-the-none-algorithm">Understanding the risks associated with the ‘none’ algorithm</a></li><li><a href="#how-to-protect-yourself-ban-none-or-explicitly-authorise-the-right-algorithms">How to protect yourself: ban "none" or explicitly authorise the right algorithms</a></li></ul></li><li><a href="#weak-secrets-and-brute-force-attacks">Weak secrets and brute force attacks</a></li><li><a href="#injection-of-specific-parameters-into-the-jose-header-of-the-jwt">Injection of specific parameters into the JOSE header of the JWT</a><ul><li><a href="#jwk">jwk</a></li><li><a href="#jku">jku</a><ul><li><a href="#jku-parameter-and-jwk-sets">jku parameter and JWK Sets</a></li><li><a href="#exploiting-the-jku">Exploiting the jku</a></li></ul></li><li><a href="#kid">kid</a></li></ul></li><li><a href="#algorithm-confusion">Algorithm Confusion</a><ul><li><a href="#how-the-algorithm-confusion-attack-works">How the Algorithm Confusion attack works</a></li><li><a href="#exploiting-the-vulnerability">Exploiting the vulnerability</a></li></ul></li></ul></li><li><a href="#how-to-secure-the-implementation-of-jwt">How to Secure the Implementation of JWT?</a></li><li><a href="#conclusion">Conclusion</a></li></ul></div>
<h2 class="wp-block-heading" id="how-does-a-jwt-work">How Does a JWT Work?</h2>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-95b7c6c395e8adbf7f411be0170d626a" id="what-is-jwt" style="color:#c0b800">What is JWT?</h3>
<p>As specified in <a href="https://datatracker.ietf.org/doc/html/rfc7519#section-6.1" rel="noopener" target="_blank" title="">RFC 7519</a>, a JSON Web Token (JWT) is a compact format for representing information, known as ‘claims’, exchanged between two parties. These claims are encapsulated in a JSON object which constitutes the content (or payload) of a signing (JWS – JSON Web Signature) or encrypted (JWE – JSON Web Encryption) structure.</p>
<p>In other words, JWT is a standard that can be implemented in two ways: either via a JWS, or via a JWE.</p>
<p>With JWS, the data is not encrypted but digitally signed. This guarantees its integrity: the content remains readable, but only a holder of the secret can generate a valid signing. This is the most commonly used form of JWT.</p>
<p>Conversely, a JWE encrypts its content entirely. The information it contains is only accessible to entities with the decryption key.</p>
<p>Since JWS is by far the most widespread implementation, the rest of this article will be based on this format. For the sake of simplicity, we will use the term JWT even when it is actually a JWS.</p>
<p>JWTs are generated by the server when a user authenticates to a web application. Once issued, these tokens are sent to the client, which automatically attaches them to each subsequent HTTP request. This enables the server to identify the user at each interaction, without requiring any further authentication.</p>
<p>The token contains information encoded and signed using a private key held by the server. Each time a JWT is received, the server can check its authenticity by recalculating the signing using its key and comparing it with the signature in the token. If the two signatures match, the JWT is considered valid.</p>
<figure class="wp-block-image size-large"><img alt="How a JWT works" class="wp-image-4533" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2022/04/JWT-Tokens-working-principles-1024x533.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2022/04/JWT-Tokens-working-principles-300x156.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2022/04/JWT-Tokens-working-principles.png 1156w" decoding="async" height="533" src="images/2_how_a_jwt_works.png" width="1024"/><noscript><img alt="How a JWT works" class="wp-image-4533" decoding="async" height="533" sizes="(max-width: 1024px) 100vw, 1024px" src="images/3_how_a_jwt_works.png" width="1024"/></noscript><figcaption class="wp-element-caption">How a JWT works</figcaption></figure>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-8f29df6fe72bc539bb66d10e37e16b6f" id="jwt-structure-and-generation" style="color:#c0b800">JWT structure and generation</h3>
<p>Let’s consider the following JWT:</p>
<figure class="wp-block-image size-large"><img alt="" class="wp-image-13335" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-example-1024x116.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-example-300x34.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-example-1536x174.png 1536w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-example.png 1582w" decoding="async" height="116" src="images/3_jwt-example-1024x116.png" width="1024"/><noscript><img alt="" class="wp-image-13335" decoding="async" height="116" sizes="(max-width: 1024px) 100vw, 1024px" src="images/4_jwt-example-1024x116.png" width="1024"/></noscript></figure>
<pre class="wp-block-code"><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaXNBZG1pbiI6ZmFsc2V9.EypViEDiJhjeuXgjtGdibxrFPFZyYKn-KqFeAw3c2No</code></pre>
<p>This type of JWT is made up of three distinct parts:</p>
<ul class="wp-block-list">
<li class="has-vivid-red-color has-text-color has-link-color wp-elements-e9242bdf97cecb71ef6bd98d153f3493">The JOSE (JSON Object Signing and Encryption) header: <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></li>
<li class="has-vivid-purple-color has-text-color has-link-color wp-elements-f6d7eb0979c187d08bf6dcd42722953e">The payload: <code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaXNBZG1pbiI6ZmFsc2V9</code></li>
<li class="has-pale-cyan-blue-color has-text-color has-link-color wp-elements-97858e16b16fed725b84fdf63472ebd9">The signature: <code>EypViEDiJhjeuXgjtGdibxrFPFZyYKn-KqFeAw3c2No</code></li>
</ul>
<p>Each part is separated by a ‘.’ with the JOSE header and payload encoded in base64url. The signature, meanwhile, is generated based on a secret or a pair of cryptographic keys.</p>
<p>Let’s decode this JWT with <a href="https://gchq.github.io/CyberChef/" rel="noopener" target="_blank" title="">CyberChef</a>: </p>
<figure class="wp-block-image size-large"><img alt="" class="wp-image-13337" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/decoding-jwt-1024x378.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/decoding-jwt-300x111.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/decoding-jwt.png 1528w" decoding="async" height="378" src="images/4_decoding-jwt-1024x378.png" width="1024"/><noscript><img alt="" class="wp-image-13337" decoding="async" height="378" sizes="(max-width: 1024px) 100vw, 1024px" src="images/5_decoding-jwt-1024x378.png" width="1024"/></noscript></figure>
<h4 class="wp-block-heading" id="jose-header">JOSE header</h4>
<pre class="wp-block-code"><code>{
   "alg": "HS256",
   "typ": "JWT"
}</code></pre>
<p>The JOSE header of a JWT contains two key parameters: <code>alg</code> and <code>typ</code>. The alg parameter indicates the signing algorithm used, while <code>typ</code> specifies the type of token. Only <code>alg</code> is mandatory, but other optional parameters can also be added as required. Some of these will be discussed later in this article.</p>
<h4 class="wp-block-heading" id="payload">Payload</h4>
<pre class="wp-block-code"><code>{
   "sub": "1234567890",
   "name": "John Doe",
   "isAdmin": false
}</code></pre>
<p>The payload of a JWT contains what are known as claims, i.e. the information that the token carries. In our example, the claims are <code>sub</code>, <code>name</code> and <code>isAdmin</code>.</p>
<p>There are three types of claim names:</p>
<ul class="wp-block-list">
<li>Claims registered by RFC 7519 (such as <code>sub</code>)</li>
<li>Public claims, which are standardised and listed in the IANA ‘JSON Web Token Claims’ registry to avoid name collisions.</li>
<li>Finally, private claims, freely defined by developers according to the needs of the application</li>
</ul>
<p>In our case :</p>
<ul class="wp-block-list">
<li><code>sub</code> (for Subject) is a standard claim in RFC 7519. It designates the main entity to which the JWT refers (often the user ID).</li>
<li><code>name</code> is a public claim, used here to indicate the user’s name.</li>
<li><code>isAdmin</code> is a private claim, added by the developer to indicate whether or not the user has administrator rights on the platform.</li>
</ul>
<p>There are many other claims defined in the RFC, but none are strictly mandatory. To find out more, please consult the dedicated section of RFC <a href="https://datatracker.ietf.org/doc/html/rfc7519#section-4.1" rel="noopener" target="_blank" title="">7519</a>.</p>
<h4 class="wp-block-heading" id="signature">Signature</h4>
<h5 class="wp-block-heading" id="the-crucial-role-of-the-signature-in-jwt-security">The crucial role of the signature in JWT security</h5>
<p>The signature is the element that gives the JWT its security. It is calculated from the JOSE header, the payload and a secret known only to the server.</p>
<p>Thanks to this mechanism, any modification of the token (for example by an attacker trying to falsify the data) would result in an invalid signature. The server, by recalculating the signature with the secret, will then detect the inconsistency and reject the JWT. This is why it is crucial that this secret remains confidential: if it were to leak, an attacker could generate perfectly valid fraudulent tokens.</p>
<h5 class="wp-block-heading" id="signing-algorithms-symmetric-hs256-vs-asymmetric-rs256">Signing algorithms: symmetric (HS256) vs. asymmetric (RS256)</h5>
<p>The signature can be generated using various algorithms defined in the JWA specification – JSON Web Algorithms. Depending on the algorithm used, the secret can be:</p>
<ul class="wp-block-list">
<li>Symmetric, with the same shared key for signing and verification (e.g. HS256)</li>
<li>Asymmetric, with a private key/public key pair (e.g. RS256)</li>
</ul>
<p>In the case of an asymmetric key, the public key can be exposed by the server in a standardised format defined in the JWK – JSON Web Key specification. This enables third parties to check the validity of the signature, without ever having access to the private key.</p>
<p>Let’s take a first example: a JWT signed using a symmetric key and the HS256 algorithm. In this case, the signature is generated as follows:</p>
<figure class="wp-block-image size-large"><img alt="" class="wp-image-13339" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-signing-1024x82.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-signing-300x24.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-signing-1536x123.png 1536w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-signing.png 1571w" decoding="async" height="82" src="images/5_jwt-signing-1024x82.png" width="1024"/><noscript><img alt="" class="wp-image-13339" decoding="async" height="82" sizes="(max-width: 1024px) 100vw, 1024px" src="images/6_jwt-signing-1024x82.png" width="1024"/></noscript></figure>
<pre class="wp-block-code"><code>HMACSHA256(base64UrlEncode(&lt;en-tête JOSE&gt;) + "." + base64UrlEncode(&lt;payload&gt;), "aVerySecretSecret")</code></pre>
<p>The result is then encoded in base64url and added to the end of the JWT. The server, in possession of the same secret, can recalculate this signature when it receives the token and compare it with the one provided. If the two correspond, the integrity and authenticity of the token are confirmed.</p>
<p>Of course, in a real case, it is essential to use a robust secret that is difficult to guess or <a href="https://www.vaadata.com/blog/brute-force-attacks-principles-and-security-best-practices/" rel="noopener" target="_blank" title="">brute force</a>.</p>
<p>As a second example, it is also possible to sign a JWT using a private/public key pair, using the RS256 algorithm (based on RSA):</p>
<figure class="wp-block-image size-large"><img alt="" class="wp-image-13341" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-signature-1024x82.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-signature-300x24.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-signature-1536x123.png 1536w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-signature.png 1577w" decoding="async" height="82" src="images/6_jwt-signature-1024x82.png" width="1024"/><noscript><img alt="" class="wp-image-13341" decoding="async" height="82" sizes="(max-width: 1024px) 100vw, 1024px" src="images/7_jwt-signature-1024x82.png" width="1024"/></noscript></figure>
<pre class="wp-block-code"><code>RSASHA256(base64UrlEncode(&lt;en-tête JOSE&gt;) + "." + base64UrlEncode(&lt;payload&gt;), &lt;clé privée&gt;)</code></pre>
<p>The advantage here is that only the server with the private key can generate a valid signature, but verification can be delegated to other services via the public key, which is particularly useful in distributed or microservice architectures.</p>
<h2 class="wp-block-heading" id="pros-and-cons-of-jwts">Pros And Cons of JWTs</h2>
<p>Using a JWT instead of a session identifier has certain advantages, but also some notable disadvantages.</p>
<p>The positive points include, above all, interoperability: a JWT can easily be transmitted between several applications, even if they use different technologies. Unlike a traditional session, there is no need to store server-side state, which simplifies management. Simply checking the token’s signature authenticates the user, without having to query a database or session system.</p>
<p>What’s more, the JWT format (JSON encoded in base64url) makes it a compact and readable way of transporting data, often used in distributed architectures or APIs.</p>
<p>But this stateless operation also has a major drawback: a JWT cannot be invalidated before its expiry date. If a token is ever compromised or a user needs to be disconnected immediately, you will need to either:</p>
<ul class="wp-block-list">
<li>set up a server-side blacklist (which reintroduces a form of state),</li>
<li>or wait for the JWT to expire, which can cause security problems.</li>
</ul>
<h2 class="wp-block-heading" id="what-are-the-most-common-jwt-vulnerabilities-and-exploitations">What are the Most Common JWT Vulnerabilities and Exploitations?</h2>
<p>For an attacker, compromising a JWT can be particularly interesting, as it amounts to compromising the application’s entire authentication system. If the attacker manages to manipulate a valid JWT, he can modify its identity, escalate his privileges and even access the accounts of other users.</p>
<p>Normally, such an attack is impossible thanks to the signing mechanism, which guarantees the integrity of the token. But if the application is badly configured or vulnerable, an attacker could exploit certain loopholes to modify the content of the JWT without being detected.</p>
<p>In this section, we’ll look at several common vulnerabilities related to JWT management, and how they can lead to successful attacks.</p>
<p>To illustrate these attacks, we will use:</p>
<ul class="wp-block-list">
<li>the <a href="https://jwt.io/" rel="noopener" target="_blank" title="">jwt.io</a> site to easily view and manipulate tokens,</li>
<li>and the Burp Suite extension ‘JWT Editor’ to generate or modify keys and secrets in a test context.</li>
</ul>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-177b8c4f2aedfb1e3e8d21b7589f487e" id="jwt-signature-not-verified" style="color:#c0b800">JWT signature not verified</h3>
<p>One of the first tests to be carried out on a JWT is to check whether the signature is actually verified by the server. In some cases, the developer may make the critical mistake of not checking the signature and simply decoding the JWT to read its content.</p>
<p>If this verification is not carried out, it becomes trivial for an attacker to modify the content of the token, without the server noticing. For example, if the payload contains a claim such as <code>role</code>, the attacker can simply change its value to grant himself administrator privileges, without needing a valid signature.</p>
<p>This is a serious security error, but unfortunately one that is still encountered during our <a href="https://www.vaadata.com/blog/web-application-penetration-testing-objective-methodology-black-box-grey-box-and-white-box-tests/" rel="noopener" target="_blank" title="">web penetration tests</a>.</p>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-28f5ce1844477f8dcb1e39ebf7e98156" id="exploiting-the-none-algorithm" style="color:#c0b800">Exploiting the “none” algorithm</h3>
<h4 class="wp-block-heading" id="understanding-the-risks-associated-with-the-none-algorithm">Understanding the risks associated with the ‘none’ algorithm</h4>
<p>A look at RFC 7518, which defines the algorithms that can be used to sign a JWT, reveals a surprising feature: the presence of an algorithm called <code>none</code>.</p>
<figure class="wp-block-image size-large"><img alt="JWS algorithm list" class="wp-image-13343" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-algorithms-1024x762.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-algorithms-300x223.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-algorithms.png 1177w" decoding="async" height="762" src="images/7_jws_algorithm_list.png" width="1024"/><noscript><img alt="JWS algorithm list" class="wp-image-13343" decoding="async" height="762" sizes="(max-width: 1024px) 100vw, 1024px" src="images/8_jws_algorithm_list.png" width="1024"/></noscript><figcaption class="wp-element-caption">JWS algorithm list</figcaption></figure>
<p>When the <code>none</code> algorithm is used, the JWT is not signed at all, and is therefore considered valid by default. This represents a major risk if the Web application uses a library that implicitly authorises the use of this algorithm.</p>
<p>In such a case, an attacker can simply modify the JOSE header of the JWT, replace the <code>alg</code> field with <code>none</code>, and then freely alter the contents of the token (for example, by giving himself administrator privileges). All without the need for a valid signature.</p>
<p>This type of attack is possible because the header is interpreted even before the signature has been verified, which opens the door to manipulation if the application does not carry out rigorous checks on the accepted algorithms.</p>
<p>For example, let’s say a web application returns the following JWT when the user ‘johndoe’ logs in:</p>
<figure class="wp-block-image size-large"><img alt="johndoe's JWT" class="wp-image-13345" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/johndoe-jwt-1024x400.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/johndoe-jwt-300x117.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/johndoe-jwt.png 1532w" decoding="async" height="400" src="images/8_johndoe's_jwt.png" width="1024"/><noscript><img alt="johndoe's JWT" class="wp-image-13345" decoding="async" height="400" sizes="(max-width: 1024px) 100vw, 1024px" src="images/9_johndoe's_jwt.png" width="1024"/></noscript><figcaption class="wp-element-caption">johndoe’s JWT</figcaption></figure>
<p>Even if the application correctly verifies the JWT signature, a dangerous behaviour may persist: it accepts the none algorithm.</p>
<p>This means that if an attacker modifies the JWT header to indicate <code>"alg": "none"</code> and removes the signature, the server will still accept the token as valid.</p>
<p>Once this stage has been completed, the payload can be freely modified, enabling a malicious user to be assigned an administrator role, for example. This type of vulnerability is therefore based on the absence of strict verification of the algorithm used.</p>
<p>For the application, the following JWT is therefore valid:</p>
<figure class="wp-block-image size-large"><img alt="admin JWT forged by johndoe" class="wp-image-13347" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/forged-admin-jwt-1024x393.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/forged-admin-jwt-300x115.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/forged-admin-jwt.png 1525w" decoding="async" height="393" src="images/9_admin_jwt_forged_by_johndoe.png" width="1024"/><noscript><img alt="admin JWT forged by johndoe" class="wp-image-13347" decoding="async" height="393" sizes="(max-width: 1024px) 100vw, 1024px" src="images/10_admin_jwt_forged_by_johndoe.png" width="1024"/></noscript><figcaption class="wp-element-caption">admin JWT forged by johndoe</figcaption></figure>
<h4 class="wp-block-heading" id="how-to-protect-yourself-ban-none-or-explicitly-authorise-the-right-algorithms">How to protect yourself: ban “none” or explicitly authorise the right algorithms</h4>
<p>To counter this vulnerability without changing the library, some developers implement a blacklist banning the explicit use of the <code>none</code> algorithm.</p>
<p>But this approach remains fragile: nothing prevents an attacker from attempting variants such as <code>NonE</code> or <code>NoNe</code>, which are likely to bypass poorly implemented checks.</p>
<p>This is why the use of a blacklist is not recommended. It is preferable to adopt a white list, explicitly defining the authorised algorithms (such as <code>HS256</code> or <code>RS256</code>). This guarantees strict control and avoids loopholes caused by lax interpretations of the algorithm.</p>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-badae42f4178abd8050354e26d7b7932" id="weak-secrets-and-brute-force-attacks" style="color:#c0b800">Weak secrets and brute force attacks</h3>
<p>Even if a Web application correctly verifies the JWT’s signature and rejects the <code>none</code> algorithm, vigilance is still required: a JWT can still be vulnerable.</p>
<p>Let’s take the case of a JWT signed with the <code>HS256</code> algorithm. This is based on a shared secret key, used both to sign and to verify the token. This means that if the secret is too simple, predictable or poorly protected, an attacker can try to find it by brute force, by testing a large list of common secrets.</p>
<p>As soon as one of the secrets tested generates a signature identical to that of the original JWT, the attacker has succeeded: he can then generate and sign his own valid tokens, and thus impersonate any user in the application.</p>
<p>For example, consider the following JWT:</p>
<figure class="wp-block-image size-large"><img alt="" class="wp-image-13349" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-with-known-secret-1024x386.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-with-known-secret-300x113.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-with-known-secret.png 1527w" decoding="async" height="386" src="images/10_jwt-with-known-secret-1024x386.png" width="1024"/><noscript><img alt="" class="wp-image-13349" decoding="async" height="386" sizes="(max-width: 1024px) 100vw, 1024px" src="images/11_jwt-with-known-secret-1024x386.png" width="1024"/></noscript><figcaption class="wp-element-caption">JWT with a known secret</figcaption></figure>
<p>To brute force the secret used to sign this JWT, it is possible to use the ‘hashcat’ tool with <a href="https://github.com/danielmiessler/SecLists/blob/master/Passwords/scraped-JWT-secrets.txt" rel="noopener" target="_blank" title="">lists of known JWT secrets</a>.</p>
<p>In our case, the following command finds the secret used to sign our JWT:</p>
<pre class="wp-block-code"><code>hashcat -a 0 -m 16500 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImpvaG5kb2UiLCJlbWFpbCI6ImRvZWpAZXhhbXBsZS5jb20iLCJpYXQiOjE3NDQwMzM0MDAsImV4cCI6MTc0NDExOTgwMH0.If5smKFyDhdY5fPN-qQOawSREJIQxRLRslQeUYTn070 /usr/share/seclists/Passwords/scraped-JWT-secrets.txt</code></pre>
<p>The <code>-a 0</code> option indicates the attack mode used by Hashcat. Here, the value <code>0</code> corresponds to a dictionary attack, i.e. the default approach. The <code>-m 16500</code> option specifies the type of hash to be attacked – in this case, type <code>16500</code> corresponds to a JWT signature.</p>
<p>You then simply need to supply the JWT to be tested and a list of secrets to try.</p>
<p>Once the search is complete and the secret has been found, you can display the result using the <code>--show</code> option.</p>
<figure class="wp-block-image size-large"><img alt="secret found with hashcat" class="wp-image-13351" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-secret-found-with-hashcat-1024x209.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-secret-found-with-hashcat-300x61.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-secret-found-with-hashcat.png 1531w" decoding="async" height="209" src="images/11_secret_found_with_hashcat.png" width="1024"/><noscript><img alt="secret found with hashcat" class="wp-image-13351" decoding="async" height="209" sizes="(max-width: 1024px) 100vw, 1024px" src="images/12_secret_found_with_hashcat.png" width="1024"/></noscript><figcaption class="wp-element-caption">secret found with hashcat</figcaption></figure>
<p>In green is the secret used to sign the JWT.</p>
<p>With this secret, the attacker can forge as many JWTs as he likes.</p>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-832b7172310d7145a72e485b48b50a66" id="injection-of-specific-parameters-into-the-jose-header-of-the-jwt" style="color:#c0b800">Injection of specific parameters into the JOSE header of the JWT</h3>
<p>In some cases, it is possible to manipulate or add parameters in the JOSE header to exploit the JWT. These parameters are specified in <a href="https://datatracker.ietf.org/doc/html/rfc7515?ref=codecurated.com#section-4.1" rel="noopener" target="_blank" title="">RFC 7515</a>.</p>
<h4 class="wp-block-heading" id="jwk">jwk</h4>
<p>Sometimes the JWT’s public key is included directly in the header. In this case, the key is in JWK (JSON Web Key) format and is placed in the <code>jwk</code> parameter of the header. A public key in JWK format is represented in the form of a JSON object. Here is an example:</p>
<pre class="wp-block-code"><code>{
    "kty": "RSA",
    "e": "AQAB",
    "kid": "09979990-6f43-4b28-acf1-a99dcb455c9f",
    "n": "u1bmuBchhoNbOuEYeyEjE_sOTng7boN7hdbcnQoNQNheSQCOwGcfZXE8vpFFdIFY6zVm8loYok6wEUtq-JjDj2jFrj68asuJrFbvAyC4M6FJhP6Ox4K4UzUQlLBEJvmbFzU-CfjyqV9xPR1q09Bg9Qc3qNeg7UYfXVgniFm5CkVjlpvtn1Xj6UHLWQ1NAqknYKcB13S4vNdAEyx69PFaRVjco9PzbJefubaZ78YpRrMKEvknim1bH1XHCj-JKb8enhgf78J4uTwG6CMvunVkY1KKbZI-AJjnRprAYHW26_fQg5GJkD13taTGSkNtpzrji6IY4ls-3z7Zz-IPpA4iHQ"
}</code></pre>
<p>However, if the server does not set up a white list of authorised public keys, an attacker can sign the JWT with his own private key and include his public key in the <code>jwk</code> parameter, associated with this private key.</p>
<p>Take the following JWT:</p>
<figure class="wp-block-image size-large"><img alt="JWT signed with RS256" class="wp-image-13353" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/rs256-signed-jwt-1024x421.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/rs256-signed-jwt-300x123.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/rs256-signed-jwt.png 1529w" decoding="async" height="421" src="images/12_jwt_signed_with_rs256.png" width="1024"/><noscript><img alt="JWT signed with RS256" class="wp-image-13353" decoding="async" height="421" sizes="(max-width: 1024px) 100vw, 1024px" src="images/13_jwt_signed_with_rs256.png" width="1024"/></noscript><figcaption class="wp-element-caption">JWT signed with RS256</figcaption></figure>
<p>This JWT is signed with the RS256 algorithm, using a private/public key pair. The private key is known only to the server. However, in this scenario, the server accepts the use of the <code>jwk</code> parameter and allows any public key to be added. An attacker can therefore:</p>
<ol class="wp-block-list">
<li>Modify the JWT (for example, change the value of the <code>username</code> claim from ‘johndoe’ to ‘admin’).</li>
<li>Add their own public key to the header’s <code>jwk</code> parameter.</li>
<li>Sign the JWT with its own private RSA key.</li>
</ol>
<p>The final JWT will look like this:</p>
<figure class="wp-block-image size-large"><img alt="JWT with jwk " class="wp-image-13355" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-with-jwk-1024x657.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-with-jwk-300x192.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-with-jwk.png 1534w" decoding="async" height="657" src="images/13_jwt_with_jwk_.png" width="1024"/><noscript><img alt="JWT with jwk " class="wp-image-13355" decoding="async" height="657" sizes="(max-width: 1024px) 100vw, 1024px" src="images/14_jwt_with_jwk_.png" width="1024"/></noscript><figcaption class="wp-element-caption">JWT with jwk</figcaption></figure>
<p>We can see the inclusion of the <code>jwk</code> parameter, which contains the attacker’s public key in JWK format. It is also essential to add the <code>kid</code> parameter, which specifies which public key the server should use to verify the signature. In this case, the value of <code>kid</code> corresponds to that of <code>jwk</code>, which tells the server that it must use the public key included in the <code>jwk</code> parameter.</p>
<p>This JWT will then be accepted by the server, and the attacker will be able to access the administrator account.</p>
<h4 class="wp-block-heading" id="jku">jku</h4>
<h5 class="wp-block-heading" id="jku-parameter-and-jwk-sets">jku parameter and JWK Sets</h5>
<p>The public key can also be exposed on an external server. In this case, it generally forms part of a list of public keys (called a JWK Set), where each key is associated with a unique identifier, the <code>kid</code>. This list is often accessible via endpoints such as <code>.well-known/jwks.json</code> or <code>/jwks.json</code>.</p>
<p>Here’s an example:</p>
<figure class="wp-block-image size-large"><img alt="JWK Set" class="wp-image-13357" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwk-set-1024x447.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwk-set-300x131.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwk-set.png 1529w" decoding="async" height="447" src="images/14_jwk_set.png" width="1024"/><noscript><img alt="JWK Set" class="wp-image-13357" decoding="async" height="447" sizes="(max-width: 1024px) 100vw, 1024px" src="images/15_jwk_set.png" width="1024"/></noscript><figcaption class="wp-element-caption">JWK Set</figcaption></figure>
<p>In this example, the JWK Set contains a single public key, which is presented in JWK format in a JSON array named <code>keys</code>.</p>
<p>To tell the server which JWK Set to use, it is possible to add the header parameter <code>jku</code> to the JWT, which specifies the URL of the server exposing this JWK Set.</p>
<p>However, like the attack on the <code>jwk</code> parameter, if the server accepts the jku parameter without whitelisting public keys or authorised domains, an attacker can:</p>
<ol class="wp-block-list">
<li>Modify the JWT.</li>
<li>Host the public key associated with the private key they are using on their own server.</li>
<li>Add the <code>jku</code> parameter to the header, with the URL of their own server as the value.</li>
<li>Add the <code>kid</code> parameter to point to the identifier of the public key hosted on its server.</li>
<li>Sign the JWT with your own private key.</li>
</ol>
<h5 class="wp-block-heading" id="exploiting-the-jku">Exploiting the jku</h5>
<p>Let’s take the previous JWT:</p>
<figure class="wp-block-image size-large"><img alt="JWT signed with RS256" class="wp-image-13353" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/rs256-signed-jwt-1024x421.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/rs256-signed-jwt-300x123.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/rs256-signed-jwt.png 1529w" decoding="async" height="421" src="images/15_jwt_signed_with_rs256.png" width="1024"/><noscript><img alt="JWT signed with RS256" class="wp-image-13353" decoding="async" height="421" sizes="(max-width: 1024px) 100vw, 1024px" src="images/15_jwt_signed_with_rs256.png" width="1024"/></noscript><figcaption class="wp-element-caption">JWT signed with RS256</figcaption></figure>
<p>The attacker can then host the public key in a JWK Set on his own server, as shown in the previous example. He can then add the <code>jku</code> parameter, pointing to the URL of his server, include the <code>kid</code> parameter and sign the JWT with his own private key.</p>
<p>The final JWT will look like this:</p>
<figure class="wp-block-image size-large"><img alt="JWT with jku" class="wp-image-13359" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-with-jku-1024x396.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-with-jku-300x116.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-with-jku.png 1530w" decoding="async" height="396" src="images/15_jwt_with_jku.png" width="1024"/><noscript><img alt="JWT with jku" class="wp-image-13359" decoding="async" height="396" sizes="(max-width: 1024px) 100vw, 1024px" src="images/16_jwt_with_jku.png" width="1024"/></noscript><figcaption class="wp-element-caption">JWT with jku</figcaption></figure>
<p>It is crucial that the <code>kid</code> in the JWT matches exactly that of the public key exposed on the server, so that the server uses the correct key in the JWK Set. Once this stage has been completed, the JWT will be accepted by the server, allowing the attacker to gain access to the administrator account.</p>
<p>It is also important to note that, as it is the server that makes the request to retrieve the public key from an external server, this opens the door to a risk of <a href="https://www.vaadata.com/blog/understanding-web-vulnerability-server-side-request-forgery-1/" rel="noopener" target="_blank" title="">SSRF (Server-Side Request Forgery)</a>. However, this specific exploitation will not be detailed in this article.</p>
<h4 class="wp-block-heading" id="kid">kid</h4>
<p>As you can see, the <code>kid</code> header parameter tells the server which public key to use to verify the JWT’s signature. Regardless of the location of the public key, the server generally looks for one that has the same <code>kid</code> as the one present in the JWT. However, depending on how the server manages the value of the <code>kid</code>, classic vulnerabilities such as <a href="https://www.vaadata.com/blog/sql-injections-principles-impacts-exploitations-security-best-practices/" rel="noopener" target="_blank" title="">SQL injection</a> or <a href="https://www.vaadata.com/blog/understanding-preventing-path-traversal-vulnerability/" rel="noopener" target="_blank" title="">path traversal</a> can occur.</p>
<p>In the following example, a path traversal vulnerability is present in the <code>kid</code> parameter, and the JWT is signed using a symmetric algorithm, HS256.</p>
<figure class="wp-block-image size-large"><img alt="JWT signed with HS256" class="wp-image-13361" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/hs256-signed-jwt-1024x397.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/hs256-signed-jwt-300x116.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/hs256-signed-jwt.png 1527w" decoding="async" height="397" src="images/16_jwt_signed_with_hs256.png" width="1024"/><noscript><img alt="JWT signed with HS256" class="wp-image-13361" decoding="async" height="397" sizes="(max-width: 1024px) 100vw, 1024px" src="images/17_jwt_signed_with_hs256.png" width="1024"/></noscript><figcaption class="wp-element-caption">JWT signed with HS256</figcaption></figure>
<p>To arbitrarily modify a JWT, the attacker can exploit the <code>kid</code> parameter by directing it to a file whose contents are known, then sign the JWT with a symmetric key whose value corresponds to the contents of this file.</p>
<p>Taking the example of the previous JWT, the attacker can first use a path traversal vulnerability in the <code>kid</code> parameter to redirect it to the <code>/dev/null</code> file. Then he creates a symmetric key whose value is an empty character string. Since the kid points to an empty value, the attacker can modify the JWT as he wishes and sign it with his empty symmetric key. Since the <code>/dev/null</code> file (and therefore the symmetric key) has an empty value, the JWT’s signature will be valid.</p>
<p>The final JWT may look like the following:</p>
<figure class="wp-block-image size-large"><img alt="JWT signed with a null byte secret" class="wp-image-13363" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/null-byte-secret-signed-jwt-1024x562.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/null-byte-secret-signed-jwt-300x165.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/null-byte-secret-signed-jwt.png 1530w" decoding="async" height="562" src="images/17_jwt_signed_with_a_null_byte_secret.png" width="1024"/><noscript><img alt="JWT signed with a null byte secret" class="wp-image-13363" decoding="async" height="562" sizes="(max-width: 1024px) 100vw, 1024px" src="images/18_jwt_signed_with_a_null_byte_secret.png" width="1024"/></noscript><figcaption class="wp-element-caption">JWT signed with a null byte secret</figcaption></figure>
<p>We can see that the JWT is signed with a secret whose value is empty. It will therefore be accepted by the server and the attacker will have an ‘admin’ role.</p>
<h3 class="wp-block-heading has-text-color has-link-color wp-elements-e4d184e48b0128e1679bd009886d3d66" id="algorithm-confusion" style="color:#c0b800">Algorithm Confusion</h3>
<h4 class="wp-block-heading" id="how-the-algorithm-confusion-attack-works">How the Algorithm Confusion attack works</h4>
<p>An application becomes vulnerable to an algorithm confusion attack when the developer uses the same public key to verify the JWT signature, whether the algorithm is symmetric or asymmetric.</p>
<p>Although it may seem unlikely, a developer can sometimes assume that the algorithm used will always be asymmetric, without explicitly checking.</p>
<p>This type of behaviour can be illustrated by the following code:</p>
<pre class="wp-block-code"><code>publicKey = &lt;public-key-of-server&gt;;
token = request.getCookie("jwt");
verify(token, publicKey); </code></pre>
<p>If the server allows the user to modify the algorithm in the JWT, an attacker can choose a symmetric algorithm and use the public key as a secret.</p>
<h4 class="wp-block-heading" id="exploiting-the-vulnerability">Exploiting the vulnerability</h4>
<p>To exploit this vulnerability, the attacker must follow several steps:</p>
<ol class="wp-block-list">
<li>Recover the public key</li>
<li>Transform the public key into a valid format</li>
<li>Modify the targeted claims and the JWT algorithm</li>
<li>Sign the JWT forged with the public key</li>
</ol>
<p>For the first stage, if the public key is not exposed by the server (via the <code>/jwks.json</code> endpoint, for example), it can be calculated from two generated JWTs. Tools such as ‘<a href="https://github.com/silentsignal/rsa_sign2n" rel="noopener" target="_blank" title="">rsa_sign2n</a>’ can be used for this.</p>
<ol class="wp-block-list"></ol>
<p>As for the second stage, it is crucial to transform the public key into a valid format, as it must be exactly identical to the one used by the server to verify the signature.</p>
<p>For example, if the attacker obtains the public key in JWK format but the server uses an X.509 PEM format to store and verify the key, the attacker will have to convert the JWK key into X.509 PEM format before signing his JWT.</p>
<p>These two steps are performed by the rsa_sign2n tool. To install and use it, here are the commands to run:</p>
<figure class="wp-block-image size-large"><img alt="installing and using rsa_sign2n" class="wp-image-13365" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/installing-and-using-rsa-sign2n-1024x246.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/installing-and-using-rsa-sign2n-300x72.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/installing-and-using-rsa-sign2n.png 1531w" decoding="async" height="246" src="images/18_installing_and_using_rsa_sign2n.png" width="1024"/><noscript><img alt="installing and using rsa_sign2n" class="wp-image-13365" decoding="async" height="246" sizes="(max-width: 1024px) 100vw, 1024px" src="images/19_installing_and_using_rsa_sign2n.png" width="1024"/></noscript><figcaption class="wp-element-caption">installing and using rsa_sign2n</figcaption></figure>
<p>The last command calculates the public key from two generated JWTs. In addition, the tool returns one or more JWTs signed in HS256 with the calculated public key, in X.509 PEM format, in order to test their validity.</p>
<figure class="wp-block-image size-large"><img alt="JWTs generated by rsa_sign2n" class="wp-image-13367" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/rsa-sign2n-generated-jwt-1024x227.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/rsa-sign2n-generated-jwt-300x66.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/rsa-sign2n-generated-jwt.png 1536w" decoding="async" height="227" src="images/19_jwts_generated_by_rsa_sign2n.png" width="1024"/><noscript><img alt="JWTs generated by rsa_sign2n" class="wp-image-13367" decoding="async" height="227" sizes="(max-width: 1024px) 100vw, 1024px" src="images/20_jwts_generated_by_rsa_sign2n.png" width="1024"/></noscript><figcaption class="wp-element-caption">JWTs generated by rsa_sign2n</figcaption></figure>
<p>If one of the JWTs is valid, this indicates that the Web application is vulnerable to an algorithm confusion attack. The next step is to modify the JWT to achieve the desired objective and to sign it again with the public key.</p>
<p>With CyberChef:</p>
<figure class="wp-block-image size-large"><img alt="JWT forged by the attacker" class="wp-image-13369" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-forged-by-attacker-1024x453.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-forged-by-attacker-300x133.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-forged-by-attacker-1536x679.png 1536w, https://www.vaadata.com/blog/wp-content/uploads/2016/12/jwt-forged-by-attacker.png 1549w" decoding="async" height="453" src="images/20_jwt_forged_by_the_attacker.png" width="1024"/><noscript><img alt="JWT forged by the attacker" class="wp-image-13369" decoding="async" height="453" sizes="(max-width: 1024px) 100vw, 1024px" src="images/21_jwt_forged_by_the_attacker.png" width="1024"/></noscript><figcaption class="wp-element-caption">JWT forged by the attacker</figcaption></figure>
<p>This JWT will then be accepted by the server. </p>
<h2 class="wp-block-heading" id="how-to-secure-the-implementation-of-jwt">How to Secure the Implementation of JWT?</h2>
<p>Here are several best practices for securing the implementation of your JWTs:</p>
<ul class="wp-block-list">
<li><strong>Clearly define the JWT configuration</strong>: specify the algorithm to be used and the claims expected in the payload. This configuration must be well documented.</li>
<li><strong>Avoid reimplementing JWT management</strong>: use libraries that are recognised and well maintained in the programming language used. These libraries manage the generation and verification of signatures and the handling of claims in a secure manner.</li>
<li><strong>Respect the defined configuration</strong>: the chosen library must follow the configuration initially defined to avoid any inconsistencies that could introduce vulnerabilities.</li>
<li><strong>Secure the use of the <code>jku</code> parameter</strong>: if this parameter is used, set up a white list of authorised domains on the server side to avoid requests to uncontrolled sources.</li>
<li><strong>Always include the <code>exp</code> (Expiration Time) claim</strong>: this limits the validity of the JWT and reduces the risks in the event of compromise.</li>
<li><strong>Use separate secrets</strong>: if you use several JWTs for different purposes or environments, make sure you sign each one with a unique secret.</li>
</ul>
<h2 class="wp-block-heading" id="conclusion">Conclusion</h2>
<p>In this article, we take a detailed look at how JSON Web Tokens (JWTs) work: their usefulness, structure, advantages and limitations. We have also identified the most common vulnerabilities, possible exploitation techniques and best practices for protecting against them.</p>
<p>If you are interested in this subject, we strongly encourage you to put these concepts into practice through interactive labs such as those offered by the <a href="https://portswigger.net/web-security/jwt" rel="noopener" target="_blank" title="">Burp Academy</a>. Not only are these labs of the highest quality, they are also backed up by clear, in-depth educational content.</p>
<p><strong>Authors: Lorenzo CARTE – Pentester &amp; Amin TRAORÉ – CMO @ Vaadata</strong></p>
</div><!-- .post-content -->
<div class="the-post-foot cf">

</div>

</article>
    </article>
</body>
</html>