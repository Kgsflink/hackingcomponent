
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nmap, the Tool for Mapping and Assessing Network Security</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            margin-bottom: 40px;
            border-bottom: 1px solid #eee;
            padding-bottom: 20px;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .date {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        .featured-image {
            max-width: 100%;
            height: auto;
            margin: 20px 0;
            border-radius: 5px;
        }
        .content {
            margin-top: 30px;
        }
        img {
            max-width: 100%;
            height: auto;
            margin: 15px 0;
            border-radius: 3px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        h2, h3, h4 {
            color: #2c3e50;
            margin-top: 30px;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .wp-block-table table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .wp-block-table th, .wp-block-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .wp-block-table th {
            background-color: #f2f2f2;
        }
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <header>
        <h1>Nmap, the Tool for Mapping and Assessing Network Security</h1>
        <div class="date">May 28, 2025</div>
        <img src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20535'%3E%3C/svg%3E" alt="Featured Image" class="featured-image">
    </header>
    
    <div class="content">
        <div class="post-content description cf entry-content content-spacious">
 <figure class="wp-block-image size-large">
  <img alt="Nmap, the Tool for Mapping and Assessing Network Security" class="wp-image-13380" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="article_images\image_1.png" data-lazy-srcset="article_images\image_1.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/Nmap-300x157.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/Nmap-1536x803.png 1536w" decoding="async" fetchpriority="high" height="535" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20535'%3E%3C/svg%3E" width="1024"/>
  <noscript>
   <img alt="Nmap, the Tool for Mapping and Assessing Network Security" class="wp-image-13380" decoding="async" fetchpriority="high" height="535" sizes="(max-width: 1024px) 100vw, 1024px" src="article_images\image_1.png" srcset="article_images\image_1.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/Nmap-300x157.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/Nmap-1536x803.png 1536w" width="1024"/>
  </noscript>
 </figure>
 <span id="more-13469">
 </span>
 <h2 class="wp-block-heading">
  Introduction
 </h2>
 <p>
  When it comes to mapping a network, one name always comes up: Nmap. A must-have in the world of cybersecurity, this Swiss army knife of network reconnaissance is the tool of choice for identifying exposed services, detecting open ports and laying the foundations for an effective
  <a href="https://www.vaadata.com/blog/internal-penetration-testing-objective-methodology-black-box-and-grey-box-tests/" rel="noopener" target="_blank" title="">
   internal penetration test
  </a>
  .
 </p>
 <p>
  As infrastructures become increasingly hybrid and complex, the ability to accurately visualise accessible systems is more crucial than ever. In this respect, Nmap remains the industry standard.
 </p>
 <p>
  Thanks to its multiple features, it can not only scan hosts, but also detect software versions, identify operating systems and observe the reactions of firewalls or IDS in place.
 </p>
 <p>
  In this article, we will illustrate the principle of network reconnaissance (mapping and discovery) through a detailed presentation of Nmap’s operation and features, supported by case studies.
 </p>
 <h2 class="wp-block-heading">
  Comprehensive Guide to Nmap
 </h2>
 <div class="wp-block-aioseo-table-of-contents">
  <ul>
   <li>
    <a href="#how-does-nmap-work">
     How does Nmap Work?
    </a>
    <ul>
     <li>
      <a href="#what-is-nmap">
       What is Nmap?
      </a>
     </li>
     <li>
      <a href="#nmap-usage-example">
       Nmap usage example
      </a>
     </li>
     <li>
      <a href="#how-to-use-nmap">
       How to use Nmap?
      </a>
      <ul>
       <li>
        <a href="#port-scanning-and-scanning-techniques">
         Port scanning and scanning techniques
        </a>
        <ul>
         <li>
          <a href="#tcp-syn-scan-ss">
           TCP SYN Scan (-sS)
          </a>
         </li>
         <li>
          <a href="#tcp-connect-scan-st">
           TCP Connect Scan (-sT)
          </a>
         </li>
         <li>
          <a href="#tcp-ack-scan-sa">
           TCP ACK Scan (-sA)
          </a>
         </li>
         <li>
          <a href="#udp-scan-su">
           UDP Scan (-sU)
          </a>
         </li>
         <li>
          <a href="#tcp-null-scan-sn">
           TCP NULL Scan (-sN)
          </a>
         </li>
         <li>
          <a href="#tcp-fin-scan-sf">
           TCP FIN Scan (-sF)
          </a>
         </li>
         <li>
          <a href="#tcp-xmas-scan-sx">
           TCP Xmas Scan (-sX)
          </a>
         </li>
         <li>
          <a href="#tcp-window-scan-sw">
           TCP Window Scan (-sW)
          </a>
         </li>
         <li>
          <a href="#sctp-init-scan-sy">
           SCTP INIT Scan (-sY)
          </a>
         </li>
         <li>
          <a href="#custom-scans-with-scanflags">
           Custom scans with –scanflags
          </a>
          <ul>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <a href="#detecting-services-and-versions-with-nmap">
         Detecting services and versions with Nmap
        </a>
        <ul>
        </ul>
       </li>
       <li>
        <a href="#nmap-host-discovery">
         Nmap host discovery
        </a>
        <ul>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <a href="#advanced-usage-of-nmap">
       Advanced usage of Nmap
      </a>
      <ul>
       <li>
        <a href="#os-detection">
         OS detection
        </a>
        <ul>
        </ul>
       </li>
       <li>
        <a href="#nmap-scripts">
         Nmap Scripts
        </a>
        <ul>
        </ul>
       </li>
       <li>
        <a href="#firewall-and-ids-bypass-techniques-with-nmap">
         Firewall and IDS bypass techniques with Nmap
        </a>
        <ul>
        </ul>
       </li>
       <li>
        <a href="#ip-protocol-scanning">
         IP protocol scanning
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li>
    <a href="#conclusion">
     Conclusion
    </a>
   </li>
  </ul>
 </div>
 <h2 class="wp-block-heading" id="how-does-nmap-work">
  How does Nmap Work?
 </h2>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-f9d5a9820647d0747eca223a0702759e" id="what-is-nmap" style="color:#c0b800">
  What is Nmap?
 </h3>
 <p>
  <a href="https://nmap.org/" rel="noopener" target="_blank" title="">
   Nmap
  </a>
  , short for Network Mapper, is a key open source tool in the world of cybersecurity. Available as a command-line application and via a graphical interface (Zenmap), it runs on most operating systems.
 </p>
 <p>
  <strong>
   Nmap is generally used to collect network information on any type of device with an IP address, whether it’s an isolated machine or a set of hosts on an entire network
  </strong>
  . Nmap was originally designed for two basic purposes:
 </p>
 <ul class="wp-block-list">
  <li>
   Scan a specific host to identify active services and open ports;
  </li>
  <li>
   Scan a network to detect connected hosts.
  </li>
 </ul>
 <p>
  Over the years, its functionality has expanded considerably. Thanks to its many modules, Nmap is now a veritable Swiss Army Knife of network reconnaissance.
 </p>
 <p>
  What’s more, Nmap is a versatile tool, equally suited to personal and professional use. Free and accessible, it enables anyone to identify the active services on a system. But it is above all in a professional context that it really comes into its own: whether it’s to make an inventory of the hosts and services on a network or to detect risky configurations.
 </p>
 <p>
  When it comes to cyber security, identifying exposed services, which may be vulnerable or poorly configured, is a key step in assessing a network’s level of security. And this is precisely what Nmap can do.
 </p>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-b798a0d679e356d6b085ce7618c84e84" id="nmap-usage-example" style="color:#c0b800">
  Nmap usage example
 </h3>
 <p>
  Before going into detail, let’s illustrate how Nmap works with a concrete example: scanning a host having an IP address of 172.20.0.2.
 </p>
 <figure class="wp-block-image size-full">
  <img alt="" class="wp-image-13443" data-lazy-sizes="(max-width: 766px) 100vw, 766px" data-lazy-src="article_images\image_2.png" data-lazy-srcset="article_images\image_2.png 766w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-use-case-300x97.png 300w" decoding="async" height="247" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20766%20247'%3E%3C/svg%3E" width="766"/>
  <noscript>
   <img alt="" class="wp-image-13443" decoding="async" height="247" sizes="(max-width: 766px) 100vw, 766px" src="article_images\image_2.png" srcset="article_images\image_2.png 766w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-use-case-300x97.png 300w" width="766"/>
  </noscript>
 </figure>
 <p>
  Nmap tells us that port 80 is open and that an HTTP service is probably active there. It also indicates that 999 other ports are closed.
 </p>
 <p>
  Note that, by default, Nmap only scans the 1,000 most commonly used ports; this behaviour can be changed using the
  <code>
   -p
  </code>
  option.
 </p>
 <p>
  In the following sections, we’ll take a closer look at how Nmap works and how it achieves these results. We’ll detail the different stages of a typical run, the scanning techniques available, and key features such as version detection and operating system identification.
 </p>
 <p>
  Finally, we will look at the more advanced uses of Nmap, adapted to specific contexts such as firewall evasion or automation via scripts.
 </p>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-fe27836fc470ee81cad23df9a02115f5" id="how-to-use-nmap" style="color:#c0b800">
  How to use Nmap?
 </h3>
 <p>
  Each Nmap run follows a structured sequence of steps. Depending on the options specified, some may be skipped, while others are only executed when explicitly requested.
 </p>
 <p>
  The table below summarises these different phases, in the order in which they are usually executed:
 </p>
 <figure class="wp-block-table">
  <table>
   <thead>
    <tr>
     <th>
      No.
     </th>
     <th>
      Phase
     </th>
     <th>
      Description
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      1
     </td>
     <td>
      <strong>
       Pre-scan with scripts
      </strong>
     </td>
     <td>
      Executes scripts from the
      <code>
       prerule
      </code>
      category, before any scanning phase. These may send broadcast or DNS queries, for example.
      <em>
       Default: no
      </em>
      –
      <em>
       Option:
       <code>
        --script
       </code>
       or
       <code>
        -sC
       </code>
      </em>
     </td>
    </tr>
    <tr>
     <td>
      2
     </td>
     <td>
      <strong>
       Target enumeration
      </strong>
     </td>
     <td>
      Generates the list of IPs to scan. Domain names are resolved during this phase.
      <em>
       Default: yes
      </em>
      –
      <em>
       Option: cannot be disabled
      </em>
     </td>
    </tr>
    <tr>
     <td>
      3
     </td>
     <td>
      <strong>
       Host discovery
      </strong>
     </td>
     <td>
      Detects whether each host is up or not.
      <em>
       Default: yes
      </em>
      –
      <em>
       Option: can be disabled with
       <code>
        -Pn
       </code>
      </em>
     </td>
    </tr>
    <tr>
     <td>
      4
     </td>
     <td>
      <strong>
       Reverse DNS resolution
      </strong>
     </td>
     <td>
      Attempts to retrieve domain names associated with IP addresses.
      <em>
       Default: yes
      </em>
      –
      <em>
       Option: can be disabled with
       <code>
        -n
       </code>
      </em>
     </td>
    </tr>
    <tr>
     <td>
      5
     </td>
     <td>
      <strong>
       Port scanning
      </strong>
     </td>
     <td>
      Nmap’s core function: identifying the state of ports using different techniques.
      <em>
       Default: yes
      </em>
      –
      <em>
       Option: can be disabled with
       <code>
        -sn
       </code>
      </em>
     </td>
    </tr>
    <tr>
     <td>
      6
     </td>
     <td>
      <strong>
       Version detection
      </strong>
     </td>
     <td>
      Identifies the services and versions running on open ports.
      <em>
       Default: no
      </em>
      –
      <em>
       Option:
       <code>
        -sV
       </code>
      </em>
     </td>
    </tr>
    <tr>
     <td>
      7
     </td>
     <td>
      <strong>
       Operating system detection
      </strong>
     </td>
     <td>
      Attempts to recognize the target’s operating system.
      <em>
       Default: no
      </em>
      –
      <em>
       Option:
       <code>
        -O
       </code>
      </em>
     </td>
    </tr>
    <tr>
     <td>
      8
     </td>
     <td>
      <strong>
       Traceroute
      </strong>
     </td>
     <td>
      Performs a traceroute to the target.
      <em>
       Default: no
      </em>
      –
      <em>
       Option:
       <code>
        --traceroute
       </code>
      </em>
     </td>
    </tr>
    <tr>
     <td>
      9
     </td>
     <td>
      <strong>
       Results output
      </strong>
     </td>
     <td>
      Formats and displays results (stdout, XML, JSON, files, etc.).
      <em>
       Default: yes
      </em>
      –
      <em>
       Option: cannot be disabled
      </em>
     </td>
    </tr>
    <tr>
     <td>
      10
     </td>
     <td>
      <strong>
       Post-scan with scripts
      </strong>
     </td>
     <td>
      Executes
      <code>
       postrule
      </code>
      scripts, including those explicitly requested by the user.
      <em>
       Default: no
      </em>
      –
      <em>
       Option:
       <code>
        --script
       </code>
       or
       <code>
        -sC
       </code>
      </em>
     </td>
    </tr>
   </tbody>
  </table>
  <figcaption class="wp-element-caption">
   Phases of an Nmap execution
  </figcaption>
 </figure>
 <p>
  In the following sections, we’ll focus on phases 3 (host discovery), 5 (port scanning), 6 (version detection) and 7 (OS detection), which are particularly interesting for understanding the power of Nmap.
 </p>
 <h4 class="wp-block-heading" id="port-scanning-and-scanning-techniques">
  Port scanning and scanning techniques
 </h4>
 <p>
  This phase corresponds to the fifth stage shown in the table above. The aim here is to identify which ports are open on a host.
 </p>
 <p>
  However, with the spread of security solutions at various levels – such as firewalls that block certain connections according to predefined rules – it is becoming difficult to know whether a port is actually listening or not.
 </p>
 <p>
  This is why Nmap classifies the status of a port into several categories:
 </p>
 <ul class="wp-block-list">
  <li>
   <strong>
    Open
   </strong>
  </li>
  <li>
   <strong>
    Closed
   </strong>
  </li>
  <li>
   <strong>
    Filtered
   </strong>
  </li>
  <li>
   <strong>
    Unfiltered
   </strong>
   : in some cases, Nmap cannot determine whether the port is open or closed, but it can tell whether it is filtered or not from the responses it receives.
  </li>
 </ul>
 <p>
  Nmap offers many scanning techniques that can be used to deduce the status of a port by exploiting subtle differences in protocol implementations between devices and operating systems.
 </p>
 <p>
  These methods are not always reliable, since they depend on the specific behaviour of targets, but they are still useful to know, especially when interacting with atypical systems or devices. Some of them have also been designed to be discreet.
 </p>
 <p>
  Let’s take a look at some of the port scanning techniques offered by Nmap.
 </p>
 <h5 class="wp-block-heading" id="tcp-syn-scan-ss">
  TCP SYN Scan (
  <code>
   -sS
  </code>
  )
 </h5>
 <p>
  This technique requires raw packet privileges and is used by default if the user running Nmap has the necessary rights. It works with any TCP-compliant service.
 </p>
 <p>
  The principle is as follows: Nmap sends a packet to the target port with only the SYN flag set.
 </p>
 <ul class="wp-block-list">
  <li>
   If a SYN/ACK (or sometimes just SYN) response is received, this means that the port is open.
  </li>
  <li>
   If an RST (reset) response is received, the port is closed.
  </li>
  <li>
   In the event of no response or if an ICMP ‘Destination unreachable’ message is received, the port is considered to be filtered.
  </li>
 </ul>
 <p>
  The TCP SYN scan is often referred to as a stealth scan, because Nmap does not establish a full connection: it sends an RST packet immediately after receiving a SYN/ACK, interrupting the handshake procedure before it is finalised.
 </p>
 <h5 class="wp-block-heading" id="tcp-connect-scan-st">
  TCP Connect Scan (
  <code>
   -sT
  </code>
  )
 </h5>
 <p>
  This technique is selected by default if the user running Nmap does not have the necessary privileges to send raw packets.
 </p>
 <p>
  It is based on the classic establishment of a full TCP connection with the target port, following the standard TCP handshake process. It detects port states in the same way as the SYN scan, with one difference: the TCP connect scan is not stealthy.
 </p>
 <p>
  This method completes the TCP connection by responding with a SYN/ACK, making it easy to detect. Most modern systems log all connection attempts, which can attract the attention of security solutions or network administrators.
 </p>
 <h5 class="wp-block-heading" id="tcp-ack-scan-sa">
  TCP ACK Scan (
  <code>
   -sA
  </code>
  )
 </h5>
 <p>
  Unlike previous techniques which exploit only the SYN flag, this method sends a packet with only the ACK flag set.
 </p>
 <p>
  When an open or closed port receives a packet containing only this ACK flag, it should respond with a packet containing an RST flag. So if Nmap receives an RST in response, the port is classified as unfiltered. On the other hand, if there is no response or if it receives an ICMP ‘destination unreachable’ message, the port is filtered.
 </p>
 <p>
  It is therefore important to note that this technique does not indicate whether a port is open or closed, but only whether or not it is accessible through a firewall.
 </p>
 <p>
  This approach can nevertheless be useful for analysing the configuration of a firewall. For example, it can sometimes be used to distinguish whether a firewall is stateless or stateful. Stateful firewalls keep a record of established connections and generally only allow packets belonging to an active session, or those attempting to initiate a new one.
 </p>
 <p>
  Despite its limitations, the TCP ACK scan can be used in conjunction with other techniques. By cross-checking the results, it is possible to infer whether a port is open or closed.
 </p>
 <h5 class="wp-block-heading" id="udp-scan-su">
  UDP Scan (
  <code>
   -sU
  </code>
  )
 </h5>
 <p>
  UDP scanning consists of sending empty UDP packets to the target ports, then waiting for any response. If the port responds with data, it is considered open.
 </p>
 <p>
  However, it should be borne in mind that UDP services rarely respond to empty packets or unexpected data. This makes it difficult for Nmap to know whether the lack of response is due to a service ignoring the packet, or a firewall blocking the traffic.
 </p>
 <p>
  To increase the chances of getting a response, Nmap sometimes sends data specific to certain protocols to known ports. For example, it sends a DNS request to port 53.
 </p>
 <p>
  When no response is received, Nmap classifies the status of the port as ‘open|filtered’, as it is unable to make a decision.
 </p>
 <p>
  Finally, it should be noted that UDP scanning is relatively slow, as Nmap waits several seconds by default before retransmitting a packet.
 </p>
 <h5 class="wp-block-heading" id="tcp-null-scan-sn">
  TCP NULL Scan (
  <code>
   -sN
  </code>
  )
 </h5>
 <p>
  So far, we’ve seen techniques that exploit the SYN and ACK flags. This method, on the other hand, sends a TCP packet without any flags set – hence the name NULL scan.
 </p>
 <p>
  It is based on a specific detail in the TCP RFC, which stipulates that when a closed port receives a packet without the RST flag set, it must respond with an RST packet.
 </p>
 <p>
  Thus, by sending a packet that does not contain any of the RST, SYN or ACK flags, it becomes possible to identify closed ports on systems that apply this RFC-compliant behaviour.
 </p>
 <p>
  However, this technique has one limitation: it cannot distinguish between an open port and a filtered port. The RFC states that an open port should simply ignore packets that do not contain flags SYN, ACK or RST.
 </p>
 <h5 class="wp-block-heading" id="tcp-fin-scan-sf">
  TCP FIN Scan (
  <code>
   -sF
  </code>
  )
 </h5>
 <p>
  This technique works in the same way as the TCP NULL scan, except that it sends packets with the FIN flag set.
 </p>
 <h5 class="wp-block-heading" id="tcp-xmas-scan-sx">
  TCP Xmas Scan (
  <code>
   -sX
  </code>
  )
 </h5>
 <p>
  This technique is similar to the previous one, except that the packets sent have the FIN, PSH and URG flags set, giving them a ‘Christmas tree’ appearance (hence the name Xmas).
 </p>
 <h5 class="wp-block-heading" id="tcp-window-scan-sw">
  TCP Window Scan (
  <code>
   -sW
  </code>
  )
 </h5>
 <p>
  This technique is similar to the TCP ACK scan in that it sends packets with only the ACK flag set, but it interprets the responses differently.
 </p>
 <p>
  It attempts to exploit a behaviour present on some systems: they respond with an RST packet whose window field varies according to the state of the port.
 </p>
 <ul class="wp-block-list">
  <li>
   If the port is open, the window field contains a non-zero value.
  </li>
  <li>
   If the port is closed, this value is generally zero.
  </li>
 </ul>
 <p>
  This technique only works on systems that implement this specific behaviour, which makes it unreliable overall.
 </p>
 <h5 class="wp-block-heading" id="sctp-init-scan-sy">
  SCTP INIT Scan (
  <code>
   -sY
  </code>
  )
 </h5>
 <p>
  The SCTP protocol is an alternative to the TCP/UDP protocols. Similar to the SYN scan, this technique detects that a port is open if it receives an INIT-ACK packet in response.
 </p>
 <p>
  Conversely, if it receives an ABORT packet, it considers the port to be closed.
 </p>
 <p>
  Finally, if an ICMP ‘destination unreachable’ error is received, the port is classified as filtered.
 </p>
 <h5 class="wp-block-heading" id="custom-scans-with-scanflags">
  Custom scans with
  <code>
   --scanflags
  </code>
 </h5>
 <p>
  Nmap is a flexible tool that allows users to create custom scans by specifying any combination of TCP flags.
 </p>
 <p>
  It is also possible to add a scan option such as
  <code>
   -sF
  </code>
  or
  <code>
   -sA
  </code>
  so that the results are interpreted according to the behaviour of that type of scan.
 </p>
 <p>
  If no option is specified, the results are interpreted by default as a SYN (
  <code>
   -sS
  </code>
  ) scan.
 </p>
 <h5 class="wp-block-heading" id="aioseo-scan-techniques-summary">
  Scan techniques summary
 </h5>
 <h6 class="wp-block-heading" id="aioseo-tcp">
  TCP
 </h6>
 <p>
  The table below summarises how the various TCP scanning techniques described above classify ports according to the responses they receive.
 </p>
 <figure class="wp-block-image size-large">
  <img alt="" class="wp-image-13499" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="article_images\image_3.png" data-lazy-srcset="article_images\image_3.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/tcp-scan-techniques-summary-300x89.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/tcp-scan-techniques-summary.png 1039w" decoding="async" height="305" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20305'%3E%3C/svg%3E" width="1024"/>
  <noscript>
   <img alt="" class="wp-image-13499" decoding="async" height="305" sizes="(max-width: 1024px) 100vw, 1024px" src="article_images\image_3.png" srcset="article_images\image_3.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/tcp-scan-techniques-summary-300x89.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/tcp-scan-techniques-summary.png 1039w" width="1024"/>
  </noscript>
 </figure>
 <h6 class="wp-block-heading" id="aioseo-udp">
  UDP
 </h6>
 <p>
  The table below summarises the cases encountered when using the UDP scan technique.
 </p>
 <figure class="wp-block-image size-full">
  <img alt="" class="wp-image-13501" data-lazy-sizes="(max-width: 940px) 100vw, 940px" data-lazy-src="article_images\image_4.png" data-lazy-srcset="article_images\image_4.png 940w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/udp-scan-techniques-summary-300x37.png 300w" decoding="async" height="115" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20940%20115'%3E%3C/svg%3E" width="940"/>
  <noscript>
   <img alt="" class="wp-image-13501" decoding="async" height="115" sizes="(max-width: 940px) 100vw, 940px" src="article_images\image_4.png" srcset="article_images\image_4.png 940w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/udp-scan-techniques-summary-300x37.png 300w" width="940"/>
  </noscript>
 </figure>
 <h4 class="wp-block-heading" id="detecting-services-and-versions-with-nmap">
  Detecting services and versions with Nmap
 </h4>
 <p>
  This corresponds to the sixth phase mentioned in the table showing Nmap’s execution phases.
 </p>
 <p>
  At this stage, all the examples we have seen include a
  <code>
   SERVICE
  </code>
  column in the output, indicating values such as
  <code>
   http
  </code>
  .
 </p>
 <p>
  This is because, by default, Nmap tries to guess which service is running on a given port based on a file called nmap-services. This file associates port numbers with the services that are usually linked to them.
 </p>
 <p>
  However, this method is imprecise, as users are free to run any program on any port, without necessarily respecting the conventions.
 </p>
 <p>
  In the example below, Nmap correctly identifies that an http service is running on port
  <code>
   80
  </code>
  . This information appears in the
  <code>
   nmap-services
  </code>
  file (since port
  <code>
   80
  </code>
  is a registered port, commonly used for HTTP servers).
 </p>
 <p>
  However, it is unable to identify exactly what is running on port 5000, and simply describes it as
  <code>
   upnp
  </code>
  . This is logical because port
  <code>
   5000
  </code>
  is not an officially registered port, so it does not appear in the
  <code>
   nmap-services
  </code>
  file.
 </p>
 <figure class="wp-block-image size-full">
  <img alt="" class="wp-image-13436" data-lazy-sizes="(max-width: 768px) 100vw, 768px" data-lazy-src="article_images\image_5.png" data-lazy-srcset="article_images\image_5.png 768w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/service-detection-nmap-300x106.png 300w" decoding="async" height="272" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20768%20272'%3E%3C/svg%3E" width="768"/>
  <noscript>
   <img alt="" class="wp-image-13436" decoding="async" height="272" sizes="(max-width: 768px) 100vw, 768px" src="article_images\image_5.png" srcset="article_images\image_5.png 768w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/service-detection-nmap-300x106.png 300w" width="768"/>
  </noscript>
 </figure>
 <p>
  To get around this limitation and gather as much information as possible about targets, Nmap offers a complete module dedicated to service detection. This module is based on a fingerprinting method, which is much more effective than the approach based solely on the
  <code>
   nmap-services
  </code>
  static file.
 </p>
 <p>
  This module can be activated by adding the
  <code>
   -sV
  </code>
  option. Rerunning the previous scan with this option gives the following results:
 </p>
 <figure class="wp-block-image size-full">
  <img alt="" class="wp-image-13439" data-lazy-sizes="(max-width: 764px) 100vw, 764px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/adding-service-detection-module.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/adding-service-detection-module.png 764w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/adding-service-detection-module-300x108.png 300w" decoding="async" height="275" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20764%20275'%3E%3C/svg%3E" width="764"/>
  <noscript>
   <img alt="" class="wp-image-13439" decoding="async" height="275" sizes="(max-width: 764px) 100vw, 764px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/adding-service-detection-module.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/adding-service-detection-module.png 764w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/adding-service-detection-module-300x108.png 300w" width="764"/>
  </noscript>
 </figure>
 <p>
  The results now display a new
  <code>
   VERSION
  </code>
  column, which indicates that the service listening on port
  <code>
   5000
  </code>
  is most likely a nginx HTTP server, version 1.27.4.
 </p>
 <p>
  If this version of nginx is vulnerable, this information could be extremely valuable to an attacker. This is why the type of service and its version are crucial information from a security point of view.
 </p>
 <h5 class="wp-block-heading" id="aioseo-how-does-service-detection-work-in-nmap">
  How does service detection work in Nmap?
 </h5>
 <p>
  During a scan, Nmap doesn’t just list open ports. It can also try to identify the services running on these ports. To do this, it uses a file called nmap-service-probes, which contains a large list of ‘probes’.
 </p>
 <p>
  A probe is simply a small, specific message that Nmap sends to a port to see how the service will respond. By comparing the response it gets with what it expects, Nmap can guess which service is up against it (for example Apache, nginx, SSH, etc.).
 </p>
 <p>
  These probes can be modified or enhanced by advanced users to detect specific services.
 </p>
 <p>
  Below is an example of a probe:
 </p>
 <figure class="wp-block-image size-large">
  <img alt="" class="wp-image-13407" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-probe-1024x297.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-probe-1024x297.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-probe-300x87.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-probe-1536x446.png 1536w" decoding="async" height="297" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20297'%3E%3C/svg%3E" width="1024"/>
  <noscript>
   <img alt="" class="wp-image-13407" decoding="async" height="297" sizes="(max-width: 1024px) 100vw, 1024px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-probe-1024x297.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-probe-1024x297.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-probe-300x87.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-probe-1536x446.png 1536w" width="1024"/>
  </noscript>
 </figure>
 <p>
  Each probe contains several lines of directives:
 </p>
 <ul class="wp-block-list">
  <li>
   The
   <code>
    Probe
   </code>
   line describes the protocol used (TCP or UDP), the name of the probe, and the content of the message sent to the port (the ‘payload’).
  </li>
  <li>
   The
   <code>
    match
   </code>
   lines contain regular expressions: they are used to check whether the service response matches a known pattern. If it matches, the service is identified!
  </li>
  <li>
   The
   <code>
    ports
   </code>
   directive lists the ports on which this probe is usually effective.
  </li>
 </ul>
 <h5 class="wp-block-heading" id="aioseo-detection-process-stages">
  Detection process stages
 </h5>
 <p>
  For each port found to be open or open|filtered, Nmap proceeds as follows:
 </p>
 <ol class="wp-block-list">
  <li>
   It selects the compatible probes (protocol + port mentioned).
  </li>
  <li>
   It sends each probe to the port :
   <ul class="wp-block-list">
    <li>
     If a response is received, it tests the response with the match rules. When none matches, it tries a
     <code>
      fallback
     </code>
     probe.
    </li>
    <li>
     If no response is received, it moves on to the next probe.
    </li>
   </ul>
  </li>
  <li>
   If no probe matches :
   <ul class="wp-block-list">
    <li>
     Nmap tries some other probes, even if the port is not specifically mentioned.
    </li>
    <li>
     It then takes into account the rarity of the probe (rarity) and the level of verbosity requested (
     <code>
      --version-intensity
     </code>
     ).
    </li>
   </ul>
  </li>
 </ol>
 <p>
  However, it is important to note that the results of this phase are not always 100% reliable, as they depend on a database and regular expression matching tests. Detection errors can occur.
 </p>
 <ol class="wp-block-list">
  <li>
  </li>
 </ol>
 <p>
  For this reason, Nmap encourages users to report errors or contribute to the probes database.
 </p>
 <h5 class="wp-block-heading" id="aioseo-case-of-udp-services">
  Case of UDP services
 </h5>
 <p>
  As mentioned in previous sections, open UDP ports are prone to timeouts, as many UDP services will not respond if they do not recognise the data received.
 </p>
 <p>
  In contrast, the service detection phase sends protocol-specific data, which increases the chances of sending the expected data to the UDP service and getting a response back.
 </p>
 <p>
  In this case, any UDP port previously marked as
  <code>
   open|filtered
  </code>
  can be updated to
  <code>
   open
  </code>
  .
 </p>
 <h5 class="wp-block-heading" id="aioseo-how-to-detect-the-operating-system-in-this-phase">
  How to detect the operating system in this phase?
 </h5>
 <p>
  The service detection phase can also identify operating systems, as many services can reveal useful information simply by interacting with them.
 </p>
 <p>
  For example, SSH often sends a banner that may contain details of the server’s operating system. It is therefore possible to extract information about the OS during this phase.
 </p>
 <p>
  In addition, some services are known to run exclusively on specific systems or devices, allowing Nmap to infer the underlying operating system.
 </p>
 <p>
  However, Nmap provides another mechanism for operating system detection that is invoked using the
  <code>
   -O
  </code>
  option, which will be detailed in another section.
 </p>
 <h5 class="wp-block-heading" id="aioseo-focus-on-ports-excluded-by-default-in-the-service-detection-phase">
  Focus on ports excluded by default in the service detection phase
 </h5>
 <p>
  As a precaution, by default Nmap ignores ports 9100 to 9107, which are often associated with printers. Printers, as mentioned in the documentation, have a bad habit of printing everything you send them.
 </p>
 <p>
  So if an HTTP server is running on one of these ports, it will not be detected by default. Example:
 </p>
 <figure class="wp-block-image size-full">
  <img alt="" class="wp-image-13446" data-lazy-sizes="(max-width: 769px) 100vw, 769px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/excluded-ports-nmap.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/excluded-ports-nmap.png 769w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/excluded-ports-nmap-300x41.png 300w" decoding="async" height="105" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20769%20105'%3E%3C/svg%3E" width="769"/>
  <noscript>
   <img alt="" class="wp-image-13446" decoding="async" height="105" sizes="(max-width: 769px) 100vw, 769px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/excluded-ports-nmap.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/excluded-ports-nmap.png 769w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/excluded-ports-nmap-300x41.png 300w" width="769"/>
  </noscript>
 </figure>
 <p>
  We see that the port has not been identified as an HTTP server. But if we add
  <code>
   --allports
  </code>
  to force Nmap to scan all ports:
 </p>
 <figure class="wp-block-image size-full">
  <img alt="" class="wp-image-13448" data-lazy-sizes="(max-width: 765px) 100vw, 765px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/adding-allports-nmap.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/adding-allports-nmap.png 765w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/adding-allports-nmap-300x42.png 300w" decoding="async" height="108" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20765%20108'%3E%3C/svg%3E" width="765"/>
  <noscript>
   <img alt="" class="wp-image-13448" decoding="async" height="108" sizes="(max-width: 765px) 100vw, 765px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/adding-allports-nmap.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/adding-allports-nmap.png 765w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/adding-allports-nmap-300x42.png 300w" width="765"/>
  </noscript>
 </figure>
 <p>
  Nmap can identify the service and version.
 </p>
 <h4 class="wp-block-heading" id="nmap-host-discovery">
  Nmap host discovery
 </h4>
 <p>
  In addition to port scanning, Nmap can also detect the hosts accessible on a given network. This feature is particularly useful for system or network administrators, as it facilitates infrastructure management and the creation of a network inventory.
 </p>
 <p>
  Several techniques are available for this purpose.
 </p>
 <h5 class="wp-block-heading" id="aioseo-using-the-icmp-protocol">
  Using the ICMP protocol
 </h5>
 <ul class="wp-block-list">
  <li>
   <strong>
    ICMP Echo Request (
    <code>
     -PE
    </code>
    )
   </strong>
   : Nmap sends an ICMP Echo request and waits for a response (Echo Reply). If no response is received, the machine is considered to be offline. This is the default ping behaviour.
  </li>
  <li>
   <strong>
    ICMP Address Mask Request (
    <code>
     -PM
    </code>
    )
   </strong>
   : Works like -PE, but sends an ICMP Address Mask request. Useful if Echo requests are blocked.
  </li>
  <li>
   <strong>
    ICMP Timestamp Request (
    <code>
     -PP
    </code>
    )
   </strong>
   : Sends an ICMP Timestamp request to determine whether the host responds.
  </li>
 </ul>
 <h5 class="wp-block-heading" id="aioseo-using-the-arp-protocol-pr">
  Using the ARP protocol (
  <code>
   -PR
  </code>
  )
 </h5>
 <p>
  This method is particularly effective on local networks. As the ARP protocol is widely used and rarely blocked, it is a reliable solution for detecting active machines on a LAN.
 </p>
 <h5 class="wp-block-heading" id="aioseo-using-tcp-udp-protocols">
  Using TCP/UDP protocols
 </h5>
 <ul class="wp-block-list">
  <li>
   <strong>
    <code>
     -PS
    </code>
   </strong>
   : Sends a TCP SYN packet to port 443 (configurable). If a SYN/ACK or RST response is received, the host is considered active. This works well when ICMP is blocked, but services such as HTTP are allowed.
  </li>
  <li>
   <strong>
    <code>
     -PA
    </code>
   </strong>
   : Same logic as
   <code>
    -PS
   </code>
   , but sends a TCP ACK packet on default port 80.
  </li>
  <li>
   <code>
    <strong>
     -PU
    </strong>
   </code>
   : Sends a UDP packet, by default on port 40125.
  </li>
 </ul>
 <h5 class="wp-block-heading" id="aioseo-use-of-other-ip-protocols-po">
  Use of other IP protocols (
  <code>
   -PO
  </code>
  )
 </h5>
 <p>
  Nmap can also attempt to detect the presence of a host via other protocols, such as IGMP.
 </p>
 <p>
  By default, Nmap combines the following options:
 </p>
 <ul class="wp-block-list">
  <li>
   For privileged users: PE -PP -PS443 -PA80
  </li>
  <li>
   For non-privileged users: PS80,443
  </li>
 </ul>
 <p>
  Below is an example of scanning a machine on a network:
 </p>
 <figure class="wp-block-image size-full">
  <img alt="" class="wp-image-13450" data-lazy-sizes="(max-width: 764px) 100vw, 764px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/host-scanning-nmap.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/host-scanning-nmap.png 764w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/host-scanning-nmap-300x144.png 300w" decoding="async" height="366" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20764%20366'%3E%3C/svg%3E" width="764"/>
  <noscript>
   <img alt="" class="wp-image-13450" decoding="async" height="366" sizes="(max-width: 764px) 100vw, 764px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/host-scanning-nmap.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/host-scanning-nmap.png 764w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/host-scanning-nmap-300x144.png 300w" width="764"/>
  </noscript>
 </figure>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-b38bedda85321ec099f6da6c023bfe91" id="advanced-usage-of-nmap" style="color:#c0b800">
  Advanced usage of Nmap
 </h3>
 <h4 class="wp-block-heading" id="os-detection">
  OS detection
 </h4>
 <p>
  Identifying the operating system used by a target is valuable information. For example, it can be used to identify the type of device, such as routers or printers, which often run specific systems.
 </p>
 <p>
  In a security audit, this data is crucial for adapting attack payloads to the targeted environment.
 </p>
 <p>
  Nmap includes a dedicated operating system detection module, based on network fingerprinting. This method relies on a series of metrics and calculations to compare the characteristics of an unknown host with a database of known references.
 </p>
 <p>
  However, this detection may fail or produce inaccurate results. In such cases, Nmap provides a list of likely operating systems, accompanied by a trust percentage. It may also happen that the system cannot be identified at all.
 </p>
 <h5 class="wp-block-heading" id="aioseo-how-does-os-detection-work-in-nmap">
  How does OS detection work in Nmap?
 </h5>
 <p>
  The following explanations apply exclusively to IPv4.
 </p>
 <p>
  Operating system detection relies on sending several types of probes to the target. These packets may be TCP, UDP or ICMP in nature, and often include unusual data in certain fields of the packet. Nmap sends around 16 different packets and classifies the results into a dozen categories.
 </p>
 <p>
  After receiving the responses, Nmap builds a subject fingerprint by assigning specific attributes to each category, based on the returned values or calculated metrics. This fingerprint is then compared with a reference fingerprint extracted from Nmap’s database of known signatures for numerous operating systems.
 </p>
 <p>
  Here’s an example of OS detection performed on a router, using the -d option to display details of the calculated fingerprint:
 </p>
 <pre class="wp-block-code"><code># nmap -O -d -sV 192.168.1.254

Not shown: 992 closed tcp ports (reset)
PORT     STATE SERVICE  REASON         VERSION
53/tcp   open  domain   syn-ack ttl 64 dnsmasq 2.90
[... TRUNCATED RESULTS ...]

Device type: general purpose|router

Running: Linux 4.X|5.X, MikroTik RouterOS 7.X
OS CPE: cpe:/o:linux:linux_kernel:4 cpe:/o:linux:linux_kernel:5 cpe:/o:mikrotik:routeros:7 cpe:/o:linux:linux_kernel:5.6.3
OS details: Linux 4.15 - 5.19, OpenWrt 21.02 (Linux 5.4), MikroTik RouterOS 7.2 - 7.5 (Linux 5.6.3)
TCP/IP fingerprint:
OS:SCAN(V=7.95%E=4%D=5/1%OT=53%CT=1%CU=42846%PV=Y%DS=1%DC=D%G=Y%M=8C97EA%TM
OS:=68133D2C%P=arm-apple-darwin24.1.0)SEQ(SP=104%GCD=1%ISR=10D%TI=Z%CI=Z%II
OS:=I%TS=A)OPS(O1=M5B4ST11NW7%O2=M5B4ST11NW7%O3=M5B4NNT11NW7%O4=M5B4ST11NW7</code></pre>
 <p>
  The TCP/IP fingerprint block (not shown here in full) illustrates the wealth of data collected by Nmap. From this data, Nmap identified three possible operating systems for the target:
 </p>
 <ul class="wp-block-list">
  <li>
   Linux 4.15 to 5.19
  </li>
  <li>
   OpenWrt 21.02 (Linux kernel 5.4)
  </li>
  <li>
   MikroTik RouterOS 7.2 to 7.5 (Linux kernel 5.6.3)
  </li>
 </ul>
 <p>
  In addition, Nmap indicates that the targeted equipment is probably a router or standard machine.
 </p>
 <h5 class="wp-block-heading" id="aioseo-subject-fingerprint">
  Subject Fingerprint
 </h5>
 <p>
  In this section, we’re interested in the target fingerprint generated by Nmap. This is displayed in a condensed format, designed to be easily shared when reporting errors or inconsistencies.
 </p>
 <p>
  Fortunately, this format is relatively simple to decode: simply remove the OS: prefix from the beginning of each line, then add a line break after each closing parenthesis.
 </p>
 <p>
  Here’s a decoded version of the fingerprint:
 </p>
 <figure class="wp-block-image size-full">
  <img alt="" class="wp-image-13419" data-lazy-sizes="(max-width: 769px) 100vw, 769px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/subject-fingerprint.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/subject-fingerprint.png 769w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/subject-fingerprint-300x144.png 300w" decoding="async" height="370" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20769%20370'%3E%3C/svg%3E" width="769"/>
  <noscript>
   <img alt="" class="wp-image-13419" decoding="async" height="370" sizes="(max-width: 769px) 100vw, 769px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/subject-fingerprint.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/subject-fingerprint.png 769w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/subject-fingerprint-300x144.png 300w" width="769"/>
  </noscript>
 </figure>
 <p>
  Each line represents a category that summarizes the results of the probes sent, with the exception of the first. These results are expressed as attribute-value pairs, separated by the % character. The general format is:
  <code>
   CATEGORY_NAME(ATTR_1=value%ATTR_2=value%…)
  </code>
  .
 </p>
 <p>
  For example, the SEQ category provides analysis results based on statistical calculations of fields such as IP ID and initial sequence number (ISN) predictability.
 </p>
 <p>
  Another example: the R attribute, present in many categories, corresponds to responsiveness. Its value is set to Y (yes) if the target has responded to the probes associated with this category.
 </p>
 <p>
  The
  <code>
   SCAN
  </code>
  line stands out from the others: it summarizes the general conditions of the scan, including the Nmap version used, the date and the number of open ports identified.
 </p>
 <p>
  For a complete understanding of the different categories and the meaning of the attributes, please refer to the official Nmap documentation.
 </p>
 <h5 class="wp-block-heading" id="aioseo-reference-fingerprint">
  Reference Fingerprint
 </h5>
 <p>
  Once the fingerprint of the target system has been generated, Nmap compares it with all available reference fingerprints, calculating a similarity (or trust) score.
 </p>
 <p>
  Let’s take the example of the reference fingerprint corresponding to “MikroTik RouterOS”, identified in the previous analysis. All reference fingerprints are stored in the
  <code>
   nmap-os-db
  </code>
  file.
 </p>
 <figure class="wp-block-image size-full">
  <img alt="" class="wp-image-13421" data-lazy-sizes="(max-width: 766px) 100vw, 766px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/reference-fingerprint.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/reference-fingerprint.png 766w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/reference-fingerprint-300x192.png 300w" decoding="async" height="491" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20766%20491'%3E%3C/svg%3E" width="766"/>
  <noscript>
   <img alt="" class="wp-image-13421" decoding="async" height="491" sizes="(max-width: 766px) 100vw, 766px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/reference-fingerprint.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/reference-fingerprint.png 766w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/reference-fingerprint-300x192.png 300w" width="766"/>
  </noscript>
 </figure>
 <p>
  A reference fingerprint has a structure very similar to that of a target fingerprint, except that the values are not fixed: they are expressed in the form of logical tests or matching expressions.
 </p>
 <p>
  For example, in the
  <code>
   OPS
  </code>
  category, the O1 attribute is defined as follows:
  <code>
   O1=M[54E-5B4]ST11NW[2|3|5|7]
  </code>
  .
 </p>
 <ul class="wp-block-list">
  <li>
   The notation
   <code>
    [54E-5B4]
   </code>
   designates a range of hexadecimal values that can be found in this position.
  </li>
  <li>
   As for
   <code>
    [2|3|5|7]
   </code>
   , it means that the last value must be one of these precise digits (2, 3, 5 or 7).
  </li>
 </ul>
 <p>
  The first lines of the fingerprint are used to describe the operating system and version targeted by the tests that follow.
 </p>
 <h5 class="wp-block-heading" id="aioseo-match-fingerprint">
  Match Fingerprint
 </h5>
 <p>
  As previously mentioned, Nmap calculates a trust score to determine whether a collected fingerprint (subject fingerprint) matches a reference fingerprint. This score is based on a model defined at the beginning of the nmap-os-db file, recognizable by the MatchPoints directive.
 </p>
 <p>
  This directive specifies, for each attribute of each category, the number of points that can be awarded if the attribute of the fingerprint to be analyzed matches that of the reference fingerprint.
 </p>
 <p>
  Two accumulators are used: TotalPoints and GainedPoints.
 </p>
 <ul class="wp-block-list">
  <li>
   TotalPoints is the maximum sum of points that can be obtained if all attributes are identical.
  </li>
  <li>
   GainedPoints is the actual sum of points obtained based on actual matches.
  </li>
 </ul>
 <p>
  Nmap then calculates a trust score in the form of the ratio
  <code>
   GainedPoints / TotalPoints
  </code>
  , which gives a decimal number between 0 and 1.
 </p>
 <ul class="wp-block-list">
  <li>
   If the result is exactly 1, this means that the fingerprint analyzed corresponds perfectly to the reference fingerprint.
  </li>
  <li>
   Otherwise, Nmap displays this confidence score together with the guess results.
  </li>
 </ul>
 <p>
  Here’s an example of the default matching model extracted from the
  <code>
   nmap-os-db
  </code>
  file:
 </p>
 <figure class="wp-block-image size-full">
  <img alt="" class="wp-image-13425" data-lazy-sizes="(max-width: 770px) 100vw, 770px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/match-fingerprint.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/match-fingerprint.png 770w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/match-fingerprint-300x142.png 300w" decoding="async" height="365" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20770%20365'%3E%3C/svg%3E" width="770"/>
  <noscript>
   <img alt="" class="wp-image-13425" decoding="async" height="365" sizes="(max-width: 770px) 100vw, 770px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/match-fingerprint.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/match-fingerprint.png 770w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/match-fingerprint-300x142.png 300w" width="770"/>
  </noscript>
 </figure>
 <h4 class="wp-block-heading" id="nmap-scripts">
  Nmap Scripts
 </h4>
 <p>
  Nmap includes a scripting module known as the Nmap Scripting Engine (NSE). Its purpose, as the name suggests, is to execute scripts on targets, which can be very useful for automating tedious or repetitive tasks. These scripts are written in the Lua programming language.
 </p>
 <p>
  The module comes with a large collection of scripts, but users can also write and add their own custom scripts.
 </p>
 <h5 class="wp-block-heading" id="aioseo-script-execution-stages">
  Script execution stages
 </h5>
 <p>
  Scripts can be run at four distinct stages during the execution of an Nmap scan. The author of the script specifies at which stage it should run. The four possible stages are:
 </p>
 <ul class="wp-block-list">
  <li>
   <strong>
    Pre-rule scripts
   </strong>
   : run during the very first phase, called pre-scanning script. These scripts are launched before any Nmap scan. They can, for example, send broadcast requests to the network.
  </li>
  <li>
   <strong>
    Host scripts
   </strong>
   : run after Nmap has performed host discovery, port scanning, version detection and operating system identification. This type of script runs once per target host, provided that the host matches the hostrule condition defined in the script.
  </li>
  <li>
   <strong>
    Service scripts
   </strong>
   : these scripts run against listening ports that match the
   <code>
    portrule
   </code>
   rule.
  </li>
  <li>
   <strong>
    Post-rule scripts
   </strong>
   : run at the very end, once all Nmap phases have been completed. They can be used, for example, to process or format results before the end of the execution.
  </li>
 </ul>
 <h5 class="wp-block-heading" id="aioseo-script-categories">
  Script categories
 </h5>
 <p>
  Scripts are also classified into categories according to their purpose. For example:
 </p>
 <ul class="wp-block-list">
  <li>
   <strong>
    default
   </strong>
   : this category includes scripts launched by default if the
   <code>
    -sC
   </code>
   or
   <code>
    --script
   </code>
   options are used without additional arguments.
  </li>
  <li>
   <strong>
    brute
   </strong>
   : these scripts perform
   <a href="https://www.vaadata.com/blog/brute-force-attacks-principles-and-security-best-practices/" rel="noopener" target="_blank" title="">
    brute force attacks
   </a>
   . Some examples:
   <code>
    http-brute
   </code>
   (brute force attack on HTTP basic, digest or
   <a href="https://www.vaadata.com/blog/understanding-ntlm-authentication-and-ntlm-relay-attacks/" rel="noopener" target="_blank" title="">
    NTLM authentication
   </a>
   ),
   <code>
    snmp-brute
   </code>
   ,
   <code>
    oracle-brute
   </code>
   , etc.
  </li>
  <li>
   <strong>
    discovery
   </strong>
   : this category queries more directory services and registries to gather more information about the network.
  </li>
 </ul>
 <p>
  Here is an example of running Nmap using the
  <code>
   --script
  </code>
  option:
 </p>
 <figure class="wp-block-image size-full">
  <img alt="" class="wp-image-13429" data-lazy-sizes="(max-width: 767px) 100vw, 767px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/using-nmap-with-scripts.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/using-nmap-with-scripts.png 767w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/using-nmap-with-scripts-300x126.png 300w" decoding="async" height="323" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20767%20323'%3E%3C/svg%3E" width="767"/>
  <noscript>
   <img alt="" class="wp-image-13429" decoding="async" height="323" sizes="(max-width: 767px) 100vw, 767px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/using-nmap-with-scripts.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/using-nmap-with-scripts.png 767w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/using-nmap-with-scripts-300x126.png 300w" width="767"/>
  </noscript>
 </figure>
 <p>
  As you can see, the script has managed to bypass HTTP basic authentication using a brute force attack.
 </p>
 <h4 class="wp-block-heading" id="firewall-and-ids-bypass-techniques-with-nmap">
  Firewall and IDS bypass techniques with Nmap
 </h4>
 <p>
  Nmap offers several techniques for bypassing poorly configured firewalls or intrusion detection/prevention systems (IDS/IPS).
 </p>
 <p>
  Some of these techniques are only effective against older machines with obsolete software.
 </p>
 <p>
  Although they may fail against modern security tools, they are worth trying, particularly when auditing a local network.
 </p>
 <p>
  Here is an overview of some of the evasion techniques available in Nmap.
 </p>
 <h5 class="wp-block-heading" id="aioseo-ip-idle-scan-si">
  IP Idle scan (
  <code>
   -sI
  </code>
  )
 </h5>
 <p>
  This technique is useful when you are blocked from scanning the target, but can reach another machine that :
 </p>
 <ul class="wp-block-list">
  <li>
   Can contact the target and is less likely to be filtered.
  </li>
  <li>
   Generates predictable IP IDs on a global scale (which is rare on modern systems).
  </li>
 </ul>
 <p>
  This machine is called a zombie and is used to infer information about the target. The principle is as follows:
 </p>
 <ol class="wp-block-list">
  <li>
   A packet is sent to the zombie to read its current IP ID value.
  </li>
  <li>
   We launch the scan towards the target, but usurp the source IP address of the zombie.
  </li>
  <li>
   The target’s responses will be sent to the zombie, not to us.
  </li>
  <li>
   Depending on how the zombie’s IP ID changes, we can deduce the status of the port being scanned.
  </li>
 </ol>
 <p>
  There are three possible scenarios:
 </p>
 <ol class="wp-block-list">
  <li>
  </li>
 </ol>
 <ul class="wp-block-list">
  <li>
   The port is open: the target responds with a SYN/ACK → the zombie, having initiated nothing, sends an RST → the IP ID is incremented.
  </li>
  <li>
   If the port is closed: the target sends an RST → the zombie ignores → IP ID unchanged.
  </li>
  <li>
   The port is filtered: no response or ICMP response → no incrementation.
  </li>
 </ul>
 <p>
  Finally, the zombie is re-interviewed:
 </p>
 <ul class="wp-block-list">
  <li>
   If the IP ID has been incremented twice, the port is probably open.
  </li>
  <li>
   Otherwise, it is closed or filtered.
  </li>
 </ul>
 <p>
  This method depends on the behaviour of the IP ID, so it is not very reliable if the zombie machine has other active connections. It is preferable to choose a truly idle machine. Nmap provides a script called
  <code>
   ipidseq
  </code>
  to detect whether IP IDs are generated incrementally.
 </p>
 <h5 class="wp-block-heading" id="aioseo-ack-scan-sa">
  ACK scan (
  <code>
   -sA
  </code>
  )
 </h5>
 <p>
  This technique is useful for differentiating between stateful and stateless firewalls. As only packets with the ACK flag are sent, stateless firewalls can let them through, whereas stateful firewalls will check whether there is an associated connection.
 </p>
 <h5 class="wp-block-heading" id="aioseo-fragmentation">
  Fragmentation
 </h5>
 <p>
  This technique allows packets to be sent in smaller fragments. This can bypass security equipment that does not handle fragmented packets correctly.
 </p>
 <h5 class="wp-block-heading" id="aioseo-ipv6">
  IPv6
 </h5>
 <p>
  Sometimes ignored in firewall configuration, this protocol can be used to bypass certain protections via IPv6 scans.
 </p>
 <p>
  Nmap implements other interesting techniques to test during an audit: source routing, MAC address spoofing, FTP bounce, etc.
 </p>
 <h4 class="wp-block-heading" id="ip-protocol-scanning">
  IP protocol scanning
 </h4>
 <p>
  This is a special type of scan that is not included in conventional port scanning techniques. The purpose of the IP protocol scan (
  <code>
   -sO
  </code>
  ) is to identify the IP protocols supported by the target: ICMP, TCP, IGMP, etc.
 </p>
 <p>
  Rather than scanning ports as in traditional scans, this method varies the value of the Protocol field (8 bits) in the IP header, making it possible to determine which protocols are accepted or filtered by the target equipment.
 </p>
 <p>
  Here is an example of a scan performed with Nmap on a router:
 </p>
 <figure class="wp-block-image size-full">
  <img alt="" class="wp-image-13433" data-lazy-sizes="(max-width: 764px) 100vw, 764px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-scan.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-scan.png 764w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-scan-300x146.png 300w" decoding="async" height="373" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20764%20373'%3E%3C/svg%3E" width="764"/>
  <noscript>
   <img alt="" class="wp-image-13433" decoding="async" height="373" sizes="(max-width: 764px) 100vw, 764px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-scan.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-scan.png 764w, https://www.vaadata.com/blog/wp-content/uploads/2025/05/nmap-scan-300x146.png 300w" width="764"/>
  </noscript>
 </figure>
 <p>
  In this example, we can see that the ICMP (1), TCP (6), UDP (17) and SCTP (132) protocols are clearly open. Others, such as IPv6 (41), GRE (47) and ESP (50), appear as
  <code>
   open|filtered
  </code>
  , which means that Nmap cannot determine with certainty whether the protocol is authorised or simply filtered.
 </p>
 <p>
  This type of scan is particularly useful when auditing routers, firewalls or other network equipment that may allow certain protocols to pass through while blocking others.
 </p>
 <h2 class="wp-block-heading" id="conclusion">
  Conclusion
 </h2>
 <p>
  Nmap is a powerful and versatile tool that is an essential pillar in the arsenal of cybersecurity professionals. With a wide range of features – from host discovery and operating system detection to automated script execution and advanced evasion techniques – Nmap provides accurate, in-depth mapping of target networks.
 </p>
 <p>
  Its ability to adapt to different environments and audit scenarios makes it an essential ally for identifying vulnerabilities, understanding network configuration and preparing effective defence strategies. Advanced features such as fingerprint comparison and IP protocol scanning illustrate the level of analysis that can be achieved, even when dealing with complex or protected systems.
 </p>
 <p>
  Finally, the fact that Nmap incorporates an extensible scripting engine, with an extensive library and the ability to add its own Lua scripts, gives it exceptional flexibility for automating and customising audits, going far beyond a simple port scanner.
 </p>
 <p>
  Mastering Nmap means equipping yourself to better understand and protect networks, anticipate attacks and strengthen overall security. Whether for a pentest, a network analysis or a rapid diagnostic, Nmap remains an essential reference tool for any IT security expert.
 </p>
 <p>
  <strong>
   Source:
  </strong>
 </p>
 <p>
  <strong>
   Nmap
  </strong>
  <strong>
   Documentation
  </strong>
  : https://nmap.org/book/man.html
 </p>
 <p>
  <strong>
   Author: Souad SEBAA – Pentester @Vaadata
  </strong>
 </p>
</div>

    </div>
</body>
</html>
        