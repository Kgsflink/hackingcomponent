
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Upload Vulnerabilities and Security Best Practices</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            text-align: center;
            margin-bottom: 40px;
            border-bottom: 1px solid #eee;
            padding-bottom: 20px;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .date {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        .featured-image {
            max-width: 100%;
            height: auto;
            margin: 20px 0;
            border-radius: 5px;
        }
        .content {
            margin-top: 30px;
        }
        img {
            max-width: 100%;
            height: auto;
            margin: 15px 0;
            border-radius: 3px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        h2, h3, h4 {
            color: #2c3e50;
            margin-top: 30px;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .wp-block-table table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .wp-block-table th, .wp-block-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .wp-block-table th {
            background-color: #f2f2f2;
        }
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <header>
        <h1>File Upload Vulnerabilities and Security Best Practices</h1>
        <div class="date">April 29, 2025</div>
        <img src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20387'%3E%3C/svg%3E" alt="Featured Image" class="featured-image">
    </header>
    
    <div class="content">
        <div class="post-content description cf entry-content content-spacious">
 <div class="wp-block-image">
  <figure class="alignright size-large is-resized">
   <img alt="File Upload Vulnerabilities and Security Best Practices" class="wp-image-13321" decoding="async" fetchpriority="high" height="535" sizes="(max-width: 1024px) 100vw, 1024px" src="article_images\image_1.png" srcset="article_images\image_1.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/file-upload-vulnerabilities-300x157.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/file-upload-vulnerabilities-1536x803.png 1536w" style="width:445px;height:auto" width="1024"/>
  </figure>
 </div>
 <p>
  On many web applications, the option of uploading files is a standard feature.
 </p>
 <p>
  Whether it’s adding a profile photo or sending a document, file upload simplifies user interaction. But this functionality is not without risks.
 </p>
 <span id="more-13320">
 </span>
 <p>
  Poorly configured or insufficiently protected, this functionality can open the door to serious attacks, ranging from the execution of malicious code on the server to the complete compromise of the infrastructure. A simple, seemingly harmless file can become a Trojan horse, enabling an attacker to take control of the system or disrupt its operation.
 </p>
 <p>
  In this article, we will review file upload vulnerabilities. We will detail the various techniques used by attackers to bypass security mechanisms. Finally, we will outline the best practices to implement in order to effectively secure an upload feature.
 </p>
 <h2 class="wp-block-heading">
  Comprehensive Guide to File Upload Vulnerabilities
 </h2>
 <div class="wp-block-aioseo-table-of-contents">
  <ul>
   <li>
    <a href="#file-upload-vulnerabilities-exploitation-mechanisms-and-risks">
     File Upload Vulnerabilities: Exploitation Mechanisms and Risks
    </a>
    <ul>
     <li>
      <a href="#file-upload-exploitation-modes">
       File upload exploitation modes
      </a>
     </li>
     <li>
      <a href="#how-server-side-file-upload-works">
       How server-side file upload works
      </a>
     </li>
    </ul>
   </li>
   <li>
    <a href="#understanding-techniques-for-bypassing-protection-and-exploiting-file-upload-vulnerabilities">
     Understanding Techniques for Bypassing Protection and Exploiting File Upload Vulnerabilities
    </a>
    <ul>
     <li>
      <a href="#bypassing-file-extension-checks">
       Bypassing file extension checks
      </a>
      <ul>
       <li>
        <a href="#multiple-extensions">
         Multiple extensions
        </a>
       </li>
       <li>
        <a href="#the-limits-of-blacklists">
         The limits of blacklists
        </a>
       </li>
       <li>
        <a href="#fuzzing-and-black-box-techniques">
         Fuzzing and black box techniques
        </a>
       </li>
       <li>
        <a href="#injection-of-special-characters">
         Injection of special characters
        </a>
       </li>
       <li>
        <a href="#path-traversal-risks">
         Path Traversal risks
        </a>
       </li>
      </ul>
     </li>
     <li>
      <a href="#bypassing-the-mime-type">
       Bypassing the MIME type
      </a>
     </li>
     <li>
      <a href="#file-upload-using-the-put-method">
       File upload using the PUT method
      </a>
     </li>
     <li>
      <a href="#potential-consequences-of-a-file-upload-vulnerability">
       Potential consequences of a file upload vulnerability
      </a>
     </li>
    </ul>
   </li>
   <li>
    <a href="#exploiting-file-upload-vulnerabilities">
     Exploiting File Upload Vulnerabilities
    </a>
    <ul>
     <li>
      <a href="#xss-attack-using-svg-file-upload">
       XSS attack using SVG file upload
      </a>
     </li>
     <li>
      <a href="#remote-code-execution-via-webshell-upload">
       Remote code execution via webshell upload
      </a>
     </li>
    </ul>
   </li>
   <li>
    <a href="#how-to-prevent-file-upload-vulnerabilities">
     How to Prevent File Upload Vulnerabilities?
    </a>
    <ul>
     <li>
      <a href="#validate-file-content">
       Validate file content
      </a>
     </li>
     <li>
      <a href="#additional-security-measures">
       Additional security measures
      </a>
     </li>
    </ul>
   </li>
   <li>
    <a href="#conclusion">
     Conclusion
    </a>
   </li>
  </ul>
 </div>
 <h2 class="wp-block-heading" id="file-upload-vulnerabilities-exploitation-mechanisms-and-risks">
  File Upload Vulnerabilities: Exploitation Mechanisms and Risks
 </h2>
 <p>
  File uploads can represent a critical attack surface when poorly secured. Various methods can be used to exploit vulnerabilities, with the main aim of uploading a file whose type or content is not intended.
 </p>
 <p>
  Some attacks can even use apparently legitimate files, authorised by the system, but used in a roundabout way to compromise security.
 </p>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-2ca7f1814459b51be8e0d27f37f95993" id="file-upload-exploitation-modes" style="color:#c0b800">
  File upload exploitation modes
 </h3>
 <p>
  There are generally two main types of exploitation:
 </p>
 <ul class="wp-block-list">
  <li>
   On the client side: an attacker can inject malicious JavaScript code into a file, for example triggering a stored XSS vulnerability when it is displayed by a user.
  </li>
  <li>
   Server side: the upload can be used to execute arbitrary code, bypass restrictions or execute system commands, depending on the server configuration.
  </li>
 </ul>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-c7a03d3565d272f39ef3e577870709a8" id="how-server-side-file-upload-works" style="color:#c0b800">
  How server-side file upload works
 </h3>
 <p>
  When a web server receives a request for a file with the .php extension, for example, it does not simply serve the file as is. Instead, it transfers it to a PHP execution engine, such as
  <code>
   mod_php
  </code>
  for Apache or
  <code>
   PHP-FPM
  </code>
  for Nginx.
 </p>
 <p>
  This engine will then interpret the contents of the file, execute the instructions it contains (including any system commands), and generate output, usually in HTML.
 </p>
 <p>
  The web server then sends the result back to the client in the form of an HTTP response. The PHP code itself is never transmitted as is to the user’s browser. This mechanism makes it possible both to display dynamic content and to protect the source code on the server side.
 </p>
 <p>
  This has major security implications:
 </p>
 <ul class="wp-block-list">
  <li>
   If a malicious file with a .php extension is uploaded to the server, it will be executed.
  </li>
  <li>
   If a .php file is placed in a directory not interpreted by PHP (or renamed with another extension), it can be downloaded as a simple text file, exposing the source code.
  </li>
 </ul>
 <p>
  Incorrect configuration can therefore expose the code or allow commands to be executed remotely, particularly if a webshell is uploaded to a poorly protected folder.
 </p>
 <p>
  In the following sections, we will detail these different vulnerabilities and illustrate their impact using concrete examples. Finally, we will look at the security best practices that can be put in place to prevent these attacks effectively.
 </p>
 <p>
  But first, let’s take a look at the most common security mechanisms, and the techniques used by attackers to bypass them.
 </p>
 <h2 class="wp-block-heading" id="understanding-techniques-for-bypassing-protection-and-exploiting-file-upload-vulnerabilities">
  Understanding Techniques for Bypassing Protection and Exploiting File Upload Vulnerabilities
 </h2>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-f34a85df77fd1c8771e5c13b89a1e3de" id="bypassing-file-extension-checks" style="color:#c0b800">
  Bypassing file extension checks
 </h3>
 <p>
  Checking the file extension on the server side is an essential first line of defence. However, this alone does not guarantee the security of the upload mechanism.
 </p>
 <p>
  Attackers have various techniques for bypassing these checks when they are poorly implemented.
 </p>
 <h4 class="wp-block-heading" id="multiple-extensions">
  Multiple extensions
 </h4>
 <p>
  A classic bypass method is to use double or disguised extensions, such as
  <code>
   image.jpg.php
  </code>
  .
 </p>
 <p>
  If the application simply checks that the file name contains
  <code>
   .jpg
  </code>
  without checking the position or full validity, the file can be interpreted as a PHP script.
 </p>
 <h4 class="wp-block-heading" id="the-limits-of-blacklists">
  The limits of blacklists
 </h4>
 <p>
  Many applications rely on a blacklist of unauthorised extensions, blocking
  <code>
   .php
  </code>
  for example. However, this approach is easily circumvented with variants such as
  <code>
   .php5
  </code>
  ,
  <code>
   .phtml
  </code>
  , or other extensions that can be interpreted depending on the server configuration.
 </p>
 <p>
  In fact, it is strongly recommended to use a whitelist of authorised extensions (such as
  <code>
   .jpg
  </code>
  ,
  <code>
   .png
  </code>
  ,
  <code>
   .pdf
  </code>
  ) so that only the file types expected by the application are allowed to pass through.
 </p>
 <h4 class="wp-block-heading" id="fuzzing-and-black-box-techniques">
  Fuzzing and black box techniques
 </h4>
 <p>
  In a
  <a href="https://www.vaadata.com/blog/black-box-penetration-testing-objective-methodology-and-use-cases/" rel="noopener" target="_blank" title="">
   black box
  </a>
  context, an attacker will often fuzz extensions to identify which formats are accepted or poorly filtered by the application.
 </p>
 <p>
  This test phase reveals unexpected behaviour and potentially dangerous extensions.
 </p>
 <h4 class="wp-block-heading" id="injection-of-special-characters">
  Injection of special characters
 </h4>
 <p>
  The use of special characters in file names is another technique for fooling validation:
 </p>
 <ul class="wp-block-list">
  <li>
   <code>
    %20
   </code>
  </li>
  <li>
   <code>
    %0a
   </code>
  </li>
  <li>
   <code>
    %00
   </code>
  </li>
  <li>
   <code>
    %0d%0a
   </code>
  </li>
  <li>
   <code>
    /
   </code>
   or
   <code>
    .\
   </code>
  </li>
 </ul>
 <p>
  These characters can confuse filters and cause the file name or path to be misinterpreted on the server side.
 </p>
 <h4 class="wp-block-heading" id="path-traversal-risks">
  Path Traversal risks
 </h4>
 <p>
  A major danger linked to badly filtered file names is the injection of relative paths (
  <code>
   ../
  </code>
  ), or
  <a href="https://www.vaadata.com/blog/understanding-preventing-path-traversal-vulnerability/" rel="noopener" target="_blank" title="">
   Path Traversal
  </a>
  . This allows an attacker to move up the file system tree and:
 </p>
 <ul class="wp-block-list">
  <li>
   Overload or modify sensitive files (e.g.
   <code>
    config.php
   </code>
   ,
   <code>
    .htaccess
   </code>
   )
  </li>
  <li>
   Place malicious files in strategic locations accessible via HTTP
  </li>
 </ul>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-c0089987a97e2108dfe4300348b2d254" id="bypassing-the-mime-type" style="color:#c0b800">
  Bypassing the MIME type
 </h3>
 <p>
  The MIME (Multipurpose Internet Mail Extensions) type, defined by
  <a href="https://datatracker.ietf.org/doc/html/rfc6838" rel="noopener" target="_blank" title="">
   RFC 6838
  </a>
  , is used to indicate the format of a file.
 </p>
 <p>
  It is made up of two parts: the main type and the sub-type, for example
  <code>
   image/gif
  </code>
  . When a file is uploaded, this information is transmitted via the
  <code>
   Content-Type
  </code>
  header.
 </p>
 <p>
  On the server side, this validation can be carried out in two ways:
 </p>
 <ol class="wp-block-list">
  <li>
   <strong>
    Content-Type verification
   </strong>
   : based on the value sent in the HTTP request.
  </li>
  <li>
   <strong>
    Analysis of file signatures (also known as magic bytes)
   </strong>
   : these are sequences of bytes located at the beginning of the file, typical of each format (e.g.
   <code>
    GIF89a
   </code>
   for GIFs).
  </li>
 </ol>
 <p>
  Unfortunately, relying solely on these two checks is not enough to guarantee the legitimacy of the file. An attacker can create a hybrid file, combining a valid signing (for example, that of an image file), a credible Content-Type (
  <code>
   image/gif
  </code>
  ) and hidden malicious code, such as a PHP webshell.
 </p>
 <figure class="wp-block-image size-large">
  <img alt="" class="wp-image-13186" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="article_images\image_2.png" data-lazy-srcset="article_images\image_2.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/webshell-example-300x113.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/webshell-example.png 1271w" decoding="async" height="387" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20387'%3E%3C/svg%3E" width="1024"/>
  <noscript>
   <img alt="" class="wp-image-13186" decoding="async" height="387" sizes="(max-width: 1024px) 100vw, 1024px" src="article_images\image_2.png" srcset="article_images\image_2.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/webshell-example-300x113.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/webshell-example.png 1271w" width="1024"/>
  </noscript>
 </figure>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-da7969649ac9d16b9e5a089c3472e688" id="file-upload-using-the-put-method" style="color:#c0b800">
  File upload using the PUT method
 </h3>
 <p>
  The PUT method defined by
  <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.4" rel="noopener" target="_blank" title="">
   RFC 7231
  </a>
  states:
 </p>
 <p>
  ‘The PUT method requests that the state of the target resource be created or replaced by the state defined by the representation included in the payload of the request message.’
 </p>
 <p>
  In other words, when a server authorises the use of the HTTP PUT method, it accepts that a file will be created or replaced in the location specified by the URL, with the content defined in the body of the request. This opens the door to serious security breaches if this functionality is not properly restricted.
 </p>
 <p>
  Fortunately, this method is not enabled by default on most web servers. It requires explicit configuration to become operational. However, during
  <a href="https://www.vaadata.com/blog/penetration-testing-methodology-scope-and-types-of-pentests/" rel="noopener" target="_blank" title="">
   penetration tests
  </a>
  , it is not uncommon to discover poorly configured servers where the PUT method is active without access control.
 </p>
 <p>
  In this case, such a configuration would allow an attacker to:
 </p>
 <ul class="wp-block-list">
  <li>
   Upload a webshell, i.e. a file containing malicious code (usually PHP) that can be executed on the server side.
  </li>
  <li>
   Modify or replace critical files, potentially impacting the configuration or overall operation of the application.
  </li>
  <li>
   Trigger a
   <a href="https://www.vaadata.com/blog/what-is-a-dos-attack-types-exploitations-and-security-tips/" rel="noopener" target="_blank" title="">
    denial of service (DoS)
   </a>
   by overwriting files that are essential for the application to function correctly.
  </li>
 </ul>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-0b603ce7edac87711ef322fee1e2233f" id="potential-consequences-of-a-file-upload-vulnerability" style="color:#c0b800">
  Potential consequences of a file upload vulnerability
 </h3>
 <p>
  Improper management of file uploads can have critical consequences for the
  <a href="https://www.vaadata.com/blog/how-to-strengthen-the-security-of-your-web-applications-to-counter-the-most-common-attacks/" rel="noopener" target="_blank" title="">
   security of a web application
  </a>
  . When an attacker manages to exploit a vulnerability in this mechanism, several types of attack become possible:
 </p>
 <ul class="wp-block-list">
  <li>
   <strong>
    XSS (Cross-Site Scripting) vulnerabilities
   </strong>
   : SVG files, often considered safe because they are images, can contain malicious JavaScript. If these files are accessed via a browser, they can trigger a stored XSS attack, executing arbitrary code in the context of the target user’s session.
  </li>
  <li>
   <strong>
    Arbitrary file upload
   </strong>
   : Without rigorous control of the file name, an attacker can inject special characters such as
   <code>
    ../
   </code>
   (path traversal) in order to leave the intended directory and override or overwrite sensitive files on the server (e.g.
   <code>
    .htaccess
   </code>
   , configuration files, etc.), depending on system permissions.
  </li>
  <li>
   <strong>
    Denial of service (DoS) attack
   </strong>
   : If no size limit is imposed on uploads, it is possible to flood the server with large files, leading to saturation of resources and even outright crashing of the application.
  </li>
  <li>
   <strong>
    Remote Command Execution (RCE)
   </strong>
   : The most dangerous scenario: uploading a webshell. This is a file containing server-side interpreted code (PHP, ASPX, etc.), enabling the attacker to take control of the remote system, execute commands and potentially pivot to other targets. To find out more about this type of vulnerability, please refer to our write-up:
   <a href="https://www.vaadata.com/blog/rce-vulnerability-in-a-file-name/" rel="noopener" target="_blank" title="">
    RCE vulnerability in a file name
   </a>
   .
  </li>
 </ul>
 <h2 class="wp-block-heading" id="exploiting-file-upload-vulnerabilities">
  Exploiting File Upload Vulnerabilities
 </h2>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-8a1f02fa28578770738dbac4a88f1469" id="xss-attack-using-svg-file-upload" style="color:#c0b800">
  XSS attack using SVG file upload
 </h3>
 <p>
  XSS (Cross-Site Scripting) attacks linked to file uploads are a vulnerability frequently encountered during
  <a href="https://www.vaadata.com/blog/web-application-penetration-testing-objective-methodology-black-box-grey-box-and-white-box-tests/" rel="noopener" target="_blank" title="">
   web penetration tests
  </a>
  . One of the most common and effective vectors is the use of SVG files.
 </p>
 <p>
  SVG files are an XML-based image format. It is therefore possible to include JavaScript tags in their structure.
 </p>
 <p>
  These tags can be executed by the victim’s browser when they are opened, which can allow malicious code to be executed:
 </p>
 <figure class="wp-block-image size-large">
  <img alt="" class="wp-image-13191" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="article_images\image_3.png" data-lazy-srcset="article_images\image_3.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/XSS-payload-within-an-SVG-image-300x114.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/XSS-payload-within-an-SVG-image.png 1182w" decoding="async" height="389" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20389'%3E%3C/svg%3E" width="1024"/>
  <noscript>
   <img alt="" class="wp-image-13191" decoding="async" height="389" sizes="(max-width: 1024px) 100vw, 1024px" src="article_images\image_3.png" srcset="article_images\image_3.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/XSS-payload-within-an-SVG-image-300x114.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/XSS-payload-within-an-SVG-image.png 1182w" width="1024"/>
  </noscript>
 </figure>
 <p>
  Let’s consider a web application that lets you upload files with the
  <code>
   .svg
  </code>
  extension:
 </p>
 <figure class="wp-block-image size-large">
  <img alt="" class="wp-image-13193" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="article_images\image_4.png" data-lazy-srcset="article_images\image_4.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/app-svg-upload-300x146.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/app-svg-upload.png 1027w" decoding="async" height="500" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20500'%3E%3C/svg%3E" width="1024"/>
  <noscript>
   <img alt="" class="wp-image-13193" decoding="async" height="500" sizes="(max-width: 1024px) 100vw, 1024px" src="article_images\image_4.png" srcset="article_images\image_4.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/app-svg-upload-300x146.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/app-svg-upload.png 1027w" width="1024"/>
  </noscript>
 </figure>
 <p>
  The SVG file is uploaded to the server. However, when a user accesses it via his browser, the malicious content embedded in the file is interpreted and executed. This triggers the execution of JavaScript code, enabling the targeted user’s session cookie, for example, to be retrieved:
 </p>
 <figure class="wp-block-image size-large">
  <img alt="" class="wp-image-13195" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="article_images\image_5.png" data-lazy-srcset="article_images\image_5.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/xss-triggered-300x169.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/xss-triggered.png 1214w" decoding="async" height="576" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20576'%3E%3C/svg%3E" width="1024"/>
  <noscript>
   <img alt="" class="wp-image-13195" decoding="async" height="576" sizes="(max-width: 1024px) 100vw, 1024px" src="article_images\image_5.png" srcset="article_images\image_5.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/xss-triggered-300x169.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/xss-triggered.png 1214w" width="1024"/>
  </noscript>
 </figure>
 <p>
  In addition, an attacker can upload a booby-trapped SVG image and then share the link to this file with legitimate users. As soon as a user clicks on this link, the JavaScript code contained in the file is executed in the browser. This can allow the attacker to steal sensitive information, such as a session token, or cause any other effect typical of a stored XSS.
 </p>
 <p>
  In some cases, the malicious file may even be automatically displayed on a public page (for example, the home page of a site or a community space). Users will then be exposed to the attack without needing to click on anything, simply by visiting the page.
 </p>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-a380a72f5cf569e8c117d9a70612944a" id="remote-code-execution-via-webshell-upload" style="color:#c0b800">
  Remote code execution via webshell upload
 </h3>
 <p>
  Let’s take the example of a webshell upload to a vulnerable application. This attack is based on uploading a file containing malicious code, with an extension interpreted by the PHP engine. If this file is executed on the server side, the attacker can then execute remote commands, opening the way to a partial or total takeover of the system.
 </p>
 <p>
  Here is the vulnerable code:
 </p>
 <figure class="wp-block-image size-large">
  <img alt="" class="wp-image-13197" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/04/vulnerable-code-file-upload-1024x450.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/04/vulnerable-code-file-upload-1024x450.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/vulnerable-code-file-upload-300x132.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/vulnerable-code-file-upload.png 1214w" decoding="async" height="450" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20450'%3E%3C/svg%3E" width="1024"/>
  <noscript>
   <img alt="" class="wp-image-13197" decoding="async" height="450" sizes="(max-width: 1024px) 100vw, 1024px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/04/vulnerable-code-file-upload-1024x450.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/04/vulnerable-code-file-upload-1024x450.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/vulnerable-code-file-upload-300x132.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/vulnerable-code-file-upload.png 1214w" width="1024"/>
  </noscript>
 </figure>
 <p>
  In this example, uploading a file is authorised on condition that its signing corresponds to that of a JPEG or PNG file. For example, for a JPEG file, the first bytes must correspond to the
  <code>
   FFD8
  </code>
  hexadecimal signing.
 </p>
 <p>
  It is also easy to find the signatures (‘magic bytes’) specific to each type of file:
 </p>
 <figure class="wp-block-image size-large">
  <img alt="" class="wp-image-13199" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/04/webshell-upload-1024x378.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/04/webshell-upload-1024x378.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/webshell-upload-300x111.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/webshell-upload.png 1219w" decoding="async" height="378" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20378'%3E%3C/svg%3E" width="1024"/>
  <noscript>
   <img alt="" class="wp-image-13199" decoding="async" height="378" sizes="(max-width: 1024px) 100vw, 1024px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/04/webshell-upload-1024x378.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/04/webshell-upload-1024x378.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/webshell-upload-300x111.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/webshell-upload.png 1219w" width="1024"/>
  </noscript>
 </figure>
 <p>
  Thanks to this bypass, the file is correctly uploaded to the server. By accessing its location, it becomes possible to execute commands remotely:
 </p>
 <figure class="wp-block-image size-large">
  <img alt="" class="wp-image-13201" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/04/rce-exploitation-1024x160.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/04/rce-exploitation-1024x160.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/rce-exploitation-300x47.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/rce-exploitation.png 1136w" decoding="async" height="160" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20160'%3E%3C/svg%3E" width="1024"/>
  <noscript>
   <img alt="" class="wp-image-13201" decoding="async" height="160" sizes="(max-width: 1024px) 100vw, 1024px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/04/rce-exploitation-1024x160.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/04/rce-exploitation-1024x160.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/rce-exploitation-300x47.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/rce-exploitation.png 1136w" width="1024"/>
  </noscript>
 </figure>
 <h2 class="wp-block-heading" id="how-to-prevent-file-upload-vulnerabilities">
  How to Prevent File Upload Vulnerabilities?
 </h2>
 <p>
  It is strongly recommended to rely on proven frameworks to manage file upload and validation mechanisms. This significantly reduces the risk of errors and vulnerabilities.
 </p>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-29a2d2e25b20256698d241ea0a92ffec" id="validate-file-content" style="color:#c0b800">
  Validate file content
 </h3>
 <p>
  However, if a custom implementation is required, here are some basic security rules to follow:
 </p>
 <ul class="wp-block-list">
  <li>
   <strong>
    Extension validation
   </strong>
   : restrict the file types accepted (for example, to image formats only) by setting up a whitelist of authorised extensions.
  </li>
  <li>
   <strong>
    Check MIME type and signing (magic bytes)
   </strong>
   : Don’t just rely on the extension; also validate the Content-Type and the characteristic bytes (binary signing) of the file to confirm that it is the expected type.
  </li>
  <li>
   <strong>
    Strict control of file names
   </strong>
   : Avoid names containing special characters or dangerous sequences such as
   <code>
    ../
   </code>
   , which could lead to path traversal vulnerabilities. Use a list of authorised characters (e.g. alphanumeric) for file names.
  </li>
 </ul>
 <h3 class="wp-block-heading has-text-color has-link-color wp-elements-74edf4efbc96dc2377de849abb904e40" id="additional-security-measures" style="color:#c0b800">
  Additional security measures
 </h3>
 <p>
  In addition to technical validations, here are some defence-in-depth measures you can put in place to strengthen security:
 </p>
 <ul class="wp-block-list">
  <li>
   <strong>
    Hide the storage directory
   </strong>
   : Avoid making the path where uploaded files are stored public. Instead, use a dedicated server script to serve the files to the client, which allows precise control of access and avoids direct execution of a malicious file.
  </li>
  <li>
   <strong>
    Rename files with random names
   </strong>
   : When saving, assign a unique and unpredictable name (UUID, hash, etc.) to each file to prevent brute force attacks on URLs or the reuse of malicious files.
  </li>
  <li>
   <strong>
    Limit critical server language function
   </strong>
   s: Disable sensitive functions in your backend language configuration. In PHP, for example, you can disable high-risk functions via the php.ini file:
  </li>
 </ul>
 <figure class="wp-block-image size-large">
  <img alt="" class="wp-image-13206" data-lazy-sizes="(max-width: 1024px) 100vw, 1024px" data-lazy-src="https://www.vaadata.com/blog/wp-content/uploads/2025/04/php-ini-file-1024x249.png" data-lazy-srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/04/php-ini-file-1024x249.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/php-ini-file-300x73.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/php-ini-file.png 1239w" decoding="async" height="249" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%201024%20249'%3E%3C/svg%3E" width="1024"/>
  <noscript>
   <img alt="" class="wp-image-13206" decoding="async" height="249" sizes="(max-width: 1024px) 100vw, 1024px" src="https://www.vaadata.com/blog/wp-content/uploads/2025/04/php-ini-file-1024x249.png" srcset="https://www.vaadata.com/blog/wp-content/uploads/2025/04/php-ini-file-1024x249.png 1024w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/php-ini-file-300x73.png 300w, https://www.vaadata.com/blog/wp-content/uploads/2025/04/php-ini-file.png 1239w" width="1024"/>
  </noscript>
 </figure>
 <ul class="wp-block-list">
  <li>
   <strong>
    Limit the size of uploaded files
   </strong>
   : Define a strict maximum size for files to be uploaded to prevent Denial of Service (DoS) attacks, which can consist of saturating server resources with files that are too large.
  </li>
  <li>
   <strong>
    Deploy a WAF (Web Application Firewall)
   </strong>
   : A WAF enables malicious requests to be detected and blocked before they reach the application. It provides a useful additional layer of defence against common attacks. However, a WAF should never be considered as a sole protection. Experienced attackers can bypass it. It is therefore essential to integrate it into a more global security strategy.
  </li>
 </ul>
 <h2 class="wp-block-heading" id="conclusion">
  Conclusion
 </h2>
 <p>
  File uploads represent a potentially critical vulnerability for web applications when poorly implemented.
 </p>
 <p>
  Attacks such as XSS, remote command execution and arbitrary file uploads can have a major impact on a company’s security and reputation.
 </p>
 <p>
  To significantly reduce these risks, it is essential to follow best security practices and rely on proven frameworks. Rigorous implementation of the upload mechanism is an effective first line of defence in protecting applications.
 </p>
 <p>
  <strong>
   Author: Théo ARCHIMBAUD – Pentester @Vaadata
  </strong>
 </p>
</div>

    </div>
</body>
</html>
        